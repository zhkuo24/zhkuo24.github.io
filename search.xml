<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="posts/4a17b156/"/>
      <url>posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习笔记：从 C 到 C++</title>
      <link href="posts/dcd6586c/"/>
      <url>posts/dcd6586c/</url>
      
        <content type="html"><![CDATA[<h2 id="const-限定符"><a class="markdownIt-Anchor" href="#const-限定符"></a> const 限定符</h2><h3 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h3><ul><li>用 const 给字面常量起个名字，这个标识符就称为标识符常量，也成为常变量</li><li>定义的一般形式：<ul><li>const 数据类型 常量名 = 常量值</li><li>数据类型 const 常量名 = 常量值</li></ul></li><li>注意事项：<ul><li>常变量在定义时必须初始化</li><li>常变量在初始化之后，不允许再被赋值</li></ul></li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    const int a; // Error, 常量必须初始化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//    a = 200;    // Error 常量不能重新被赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p; <span class="comment">// const 在 * 左边,表示 *p 是一个常量,经由 *p 不能更改指针所指向的内容</span></span><br><span class="line">    p = &amp;b;</span><br><span class="line"><span class="comment">//    *p = 200;       // Error, 常量不能被重新赋值</span></span><br><span class="line"><span class="comment">//    int * const p2; // Error, p2 为常量 常量必须初始化</span></span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;b; <span class="comment">//const 在 * 右边,表示 p2 为常量</span></span><br><span class="line"><span class="comment">//    int c = 100;</span></span><br><span class="line"><span class="comment">//    p2 = &amp;c; // Error 常量不能重新被赋值</span></span><br><span class="line"></span><br><span class="line">    *p2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-与-define"><a class="markdownIt-Anchor" href="#const-与-define"></a> const 与 #define</h3><p>const 定义的常量与 #define 定义的符号常量的区别</p><ul><li>const 定义的常量有类型，而 #define 定义的没有类型，编译可以对前者进行类型安全检查，而后者仅仅只是做简单替换</li><li>const 定义的常量在编译时分配内存，而 #define 定义的常量在预编译时进行替换，不分配内存</li><li>作用域不同，const 定义的常变量的作用域为该变量的作用域范围，而 #define 定义的常量作用域为它的定义点到程序结束，可以在某个地方用 #undef 取消</li><li>定义常量还可以用 enum, 尽量用const enum 替换 #define 定义常量，inline 可以替换宏定义</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(a) #a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT(a, b) a##b</span></span><br><span class="line"><span class="keyword">int</span> xy = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; STR(ABCD) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//#ABCD &lt;=&gt; &quot;ABCD&quot;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; CAT(x, y) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//x##y &lt;=&gt; xy</span></span><br></pre></td></tr></table></figure><h2 id="结构体内存对齐"><a class="markdownIt-Anchor" href="#结构体内存对齐"></a> 结构体内存对齐</h2><ul><li>什么是内存对齐<ul><li>编译器为每个数据单元安排在某个合适的位置上</li><li>c 、c++ 语言非常灵活，它允许干涉“内存对齐”</li></ul></li><li>为什么要对齐<ul><li>性能原因：在对齐的地址上访问数据块</li></ul></li><li>如何对齐<ul><li>第一个数据成员放在 offset 为 0 的位置</li><li>其他成员对齐至 <code>min(sizeof(member), #pragma pack 所指定的值）</code>的整数倍</li><li>整个结构体也要对齐，结构体总大小对齐至各个成员中最大对齐数的整数倍</li></ul></li></ul><h2 id="域运算符"><a class="markdownIt-Anchor" href="#域运算符"></a> 域运算符</h2><p>C++ 中增加的作用域标识符 ::</p><ul><li>用于对与局部变量同名的全局变量进行访问</li><li>用于表示类的成员，将在类的一节中详细说明</li></ul><h2 id="new-delete-运算符"><a class="markdownIt-Anchor" href="#new-delete-运算符"></a> new delete 运算符</h2><ul><li>new 运算符可以用于创建堆空间</li><li>成功返回首地址</li><li>语法：<ul><li>指针变量 = new 数据类型</li><li>指针变量 = new 数据类型[长度n]</li></ul></li><li>例如<br /><code>int *p; p = new int;</code><br /><code>char *pStr = new char[50];</code></li><li>new 一个新对象<ul><li>内存分配</li><li>调用构造函数</li></ul></li><li>new operator   内存分配 + 调用构造函数</li><li>operator new   只分配内存</li><li>placement new  不分配内存，调用拷贝构造函数</li><li>delete运算符 用于释放堆空间</li><li>语法：<ul><li>delete 指针变量；</li><li>delete[] 指针变量；</li><li>delete p;</li><li>delete[] pStr;</li></ul></li><li>delete 释放一个对象<ul><li>调用析构函数</li><li>释放内存（operator delete)</li></ul></li></ul><h2 id="重载"><a class="markdownIt-Anchor" href="#重载"></a> 重载</h2><ul><li>相同的作用域，如果两个函数名称相同，而参数不同，称为重载 overload</li><li>函数重载又称为函数的多态性 （静态的多态）</li><li>函数重载不同形式：<ul><li>形参数量不同</li><li>形参类型不同</li><li>形参的顺序不同</li><li>形参数量和类型都不同</li></ul></li><li>调用重载函数时，编译器通过检查实际参数的个数、类型和顺序来确定相应的被调用函数。</li><li>如果返回类型不同而函数名相同、形参也相同，则是非法的，会报错</li><li>c++ 为了支持重载，需要进行 name managling 名字改编</li><li>extern “C” 实现 C 与 C++ 的混合编程</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus             <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*…*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extern &quot;C&quot;的主要作用就是为了能够正确实现C<ins>代码调用其他C语言代码。加上extern &quot;C&quot;后，会指示编译器这部分代码按C语言的进行编译，而不是C</ins>的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。</p><h3 id="带默认形参值的函数"><a class="markdownIt-Anchor" href="#带默认形参值的函数"></a> 带默认形参值的函数</h3><ul><li><p>函数在声明或定义时，可以给形参赋一些默认值</p></li><li><p>调用函数时，若没有给出实参，则按指定的默认值进行工作</p></li><li><p>函数没有声明时，在函数定义中指定形参的默认值</p></li><li><p>函数既有定义又有声明时，声明时制定后，定义后不能再指定默认值</p></li><li><p>默认值的定义必须遵守从右到左的顺序，如果某个形参没有默认值，则它左边的参数就不能有默认值</p><ul><li><code>void func1(int a, double b = 4.5, int c = 3); //合法</code></li><li><code>void func1(int a = 1, double b, int c = 3); //不合法</code></li></ul></li><li><p>函数调用时，实参与形参按从左到右的顺序进行匹配</p></li></ul><h2 id="带默认形参值的函数的二义性"><a class="markdownIt-Anchor" href="#带默认形参值的函数的二义性"></a> 带默认形参值的函数的二义性</h2><ul><li>重载的函数中如果形参中带有默认值，可能产生二义性</li><li>sum = add(10,20)语句产生二义性，可以认为该语句是调用第一个函数，也可以是第二个，因此编译器不能确定是哪一个函数。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">5</span>, <span class="keyword">int</span> y = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">5</span>, <span class="keyword">int</span> y = <span class="number">6</span>, <span class="keyword">int</span> z = <span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum = add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// sum = add(10,20)语句产生二义性，可以认为该语句是调用第一个函数，也可以是第二个，因此编译器不能确定是哪一个函数。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><h3 id="引用-2"><a class="markdownIt-Anchor" href="#引用-2"></a> 引用</h3><p>引用不是变量，仅仅是变量的别名，引用没有自己独立的空间，要与它所引用的变量共享空间，对引用所做的改变其实是对它所引用的变量的改变。</p><ul><li>引用是给一个变量起别名</li><li>定义引用的一般格式：<ul><li>类型 &amp;引用名 = 变量名；</li><li>int a = 1; int &amp;b = a; // b 是 a 的别名，因此 a 和 b 是同一个单元</li></ul></li><li>定义引用时一定要初始化，指明该引用变量是谁的别名</li><li>在实际应用中，引用一般用作参数传递与返回值</li><li>引用一经初始化，不能重新指向其他变量</li></ul><h3 id="const-引用"><a class="markdownIt-Anchor" href="#const-引用"></a> const 引用</h3><p>const 引用是指向 const 对象的引用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; refVal = ival; <span class="comment">//OK, 引用和常量都是 const</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref2 = ival; <span class="comment">//Error, 非 const 引用引用一个 const 对象</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; refVal = val;</span><br><span class="line"><span class="comment">//    int&amp; ref2 = val; // Error, nonconst reference to const object</span></span><br><span class="line"><span class="comment">//    refVal = 200;     // Error, refVal 是一个常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref3 = val2; <span class="comment">// const reference to nonconst object</span></span><br><span class="line">    <span class="keyword">double</span> val3 = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref4 = val3;  <span class="comment">// int temp = val3;</span></span><br><span class="line">                            <span class="comment">// const int&amp; ref4 = tmp;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ref4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    int&amp; ref5 = val3;  //Error</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按引用传递"><a class="markdownIt-Anchor" href="#按引用传递"></a> 按引用传递</h3><p>参数传递：值传递和指针传递</p><ul><li>值传递  形参不能更改实参</li><li>指针传递形参可以改变实参</li></ul><p>按引用传递</p><ul><li>引用传递方式是在函数定义时在形参前面加上引用符号<code>&amp;</code>,<code>swap(int &amp;a, int &amp;b)</code></li><li>按值传递方式容易理解，但形参值的改变不能对实参产生影响</li><li>地址传递方式通过形参的改变使相应的实参改变，但程序容易引起错误且难以阅读</li><li>引用作为参数对形参的任何操作都能改变相应的实参的数据，又使函数调用显得方便、自然。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    swap(a,b); <span class="comment">// 在函数调用时, 引用被初始化 x = a, y = b;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用作为返回值"><a class="markdownIt-Anchor" href="#引用作为返回值"></a> 引用作为返回值</h3><ul><li>引用的另一个作用是用于返回引用的函数</li><li>函数返回引用的一个主要目的是可以将函数放在赋值运算符的左边</li><li>注意：不能返回对局部变量的引用</li><li>返回引用：当函数返回引用类型的时候，没有复制返回值，而是返回对象的引用（即对象本身）。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 引用作为函数返回值</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">index</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i];      <span class="comment">//  返回第 i 个元素的引用,引用在函数返回的时候初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    index(<span class="number">3</span>) = <span class="number">100</span>;   <span class="comment">// 引用作为函数返回值,使得函数可以放在赋值运算符左边</span></span><br><span class="line">                      <span class="comment">// 函数返回引用,引用在函数返回的时候初始化</span></span><br><span class="line">                      <span class="comment">// index(3)是一个引用, 在函数返回的时候被初始化为 a[3]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能返回对局部变量的引用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 引用作为函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span>&amp; n2 = add(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// n2 是引用,没有自己独立的空间</span></span><br><span class="line">                         <span class="comment">// n2 的值依赖于它所引用的变量</span></span><br><span class="line">                         <span class="comment">// 如果 n2 所引用的变量的生命期结束了,也就是 n2</span></span><br><span class="line">                         <span class="comment">// 是一个无效的引用, n2 的值是不确定的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;n2 = &quot; &lt;&lt; n2 &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n2 = &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用与指针区别"><a class="markdownIt-Anchor" href="#引用与指针区别"></a> 引用与指针区别</h3><ul><li>引用访问一个变量是直接访问，而指针是间接访问</li><li>引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间</li><li>引用一经初始化不能再引用其他变量，而指针可以</li><li>尽可能使用引用， 不得已时使用指针</li></ul><p>参数传递：</p><ul><li>值传递  实参要初始化形参参数要分配空间，将实参内容拷贝到形参</li><li>引用传递 实参初始化时不分配空间</li><li>指针传递 本质值传递，如果我们要修改指针的地址，单纯使用指针传递也是不行的。** *&amp;</li></ul><h2 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h2><h3 id="内联函数-2"><a class="markdownIt-Anchor" href="#内联函数-2"></a> 内联函数</h3><ul><li>当程序执行函数调用时，系统要建立栈空间，保护现场，传递参数以及控制程序执行的转移等等，这些工作需要系统时间和空间的开销。有些情况下，函数本身功能简单，代码很短，但使用频率很高，程序频繁调用该函数所花时间却很多，从而降低程序执行效率</li><li>为了提高效率，一个解决办法就是不使用函数，直接将函数的代码嵌入到程序中，但也有缺点：一个相同的代码重复书写，而是程序的可读性没有使用函数好</li><li>为了协调效率和可读性之间的矛盾，C++ 提供了另一种方法，即定义内联函数，方法是定义函数时用修饰词 <code>inline</code>，内联函数在编译的时候是展开的，不涉及函数调用</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a: b;</span><br><span class="line">&#125;</span><br><span class="line">#define MAX(a, b) (a) &gt; (b) ? (a) : (b)</span><br></pre></td></tr></table></figure><h3 id="内联函数与带参数宏区别"><a class="markdownIt-Anchor" href="#内联函数与带参数宏区别"></a> 内联函数与带参数宏区别</h3><ul><li>内联函数调用时，要求实参和形参的类型一致，另外内联函数会先对实参表达式进行求值，然后传递给形参；而宏调用时只是用实参简单的替换形参</li><li>内联函数是在编译的时候、在调用的地方将代码展开的，而宏是在预处理时进行替换的</li><li>在 C++ 中建议采用 <code>inline</code> 函数来替换带参数的宏</li><li>在 C++ 高层次编程 推荐用 <code>const</code> <code>enum</code> <code>inline</code> 替换宏，在低层次编程中，宏很灵活</li></ul><h2 id="新的类型转换运算符"><a class="markdownIt-Anchor" href="#新的类型转换运算符"></a> 新的类型转换运算符</h2><ul><li>旧式转型：<ul><li>（T)expr</li><li>T(expr)</li></ul></li><li>新式转换<ul><li><code>const_cast&lt;T&gt;(expr)</code></li><li><code>static_cast&lt;T&gt;(expr)</code></li><li><code>reinterpret_cast&lt;T&gt;(expr)</code></li><li><code>dynamic_cast&lt;T&gt;(expr)</code> 执行”安全向下“转型操作，也就是说支持运行时识别指针或所指向的对象，这是唯一一个无法用旧式语来进行的转型操作</li></ul></li></ul><h3 id="const_cast"><a class="markdownIt-Anchor" href="#const_cast"></a> const_cast</h3><ul><li>用来移除对象的常量性（cast away the constness)</li><li>const_cast 一般用于指针或引用，不能用于对象</li><li>使用 const_cast 去除 const 限定的目的不是为了修改它的内容</li><li>使用 const_cast 去除 const 限定，通常是为了函数能够接受这个实际参数</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fun = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//    int n = const_cast&lt;int&gt;(val);  error</span></span><br><span class="line">    <span class="keyword">int</span> n = val;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    int* p = &amp;val; error, 无法从 const int* 转换为 int*</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;val);</span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val2 = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//    int&amp; refval2 = val2;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; refval2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(val2);</span><br><span class="line">    refval2 = <span class="number">300</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    fun(val2);      // error</span></span><br><span class="line">    fun(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(val2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static_cast"><a class="markdownIt-Anchor" href="#static_cast"></a> static_cast</h3><ul><li>编译器隐式执行的任何类型转换都可以由 <code>static_cast</code> 来完成，隐式转换是编译器自动执行的</li><li>当一个较大的算术类型赋值给较小的类型时，可以用 static_cast 进行强制转换</li><li>可以将 <code>void*</code> 指针转为某一类型指针</li><li>可以将基类指针转为派生类指针</li><li>无法将 const 转为为 nonconst，只能使用 const_cast</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;n;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p);</span><br></pre></td></tr></table></figure><h3 id="reinterpret_cast"><a class="markdownIt-Anchor" href="#reinterpret_cast"></a> reinterpret_cast</h3><ul><li>reinterpret_cast 通常为操作数的位模式提供较底层的重新解释，也就是说将数据以二进制存在形式的重新解释</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;This is a example&quot;</span>;</span><br><span class="line">i = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line"><span class="comment">//此时结果,i与p的值完全相同的</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);</span><br><span class="line"><span class="comment">//程序员需要记得pc所指向的真是对象是 int 型,并非字符串</span></span><br><span class="line"><span class="comment">//如果将pc当作字符串指针进行操作,可能会造成运行时错误</span></span><br><span class="line"><span class="comment">//如 int len = strlen(pc);</span></span><br></pre></td></tr></table></figure><h3 id="转型规则"><a class="markdownIt-Anchor" href="#转型规则"></a> 转型规则</h3><ul><li>尽量避免使用强制类型转换</li><li>若无法避免，尽量使用新式的类型转换</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
