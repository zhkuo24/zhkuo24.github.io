<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="posts/4a17b156/"/>
      <url>posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三种容器简单介绍 string vector map</title>
      <link href="posts/bd50476c/"/>
      <url>posts/bd50476c/</url>
      
        <content type="html"><![CDATA[<h1 id="string-介绍"><a class="markdownIt-Anchor" href="#string-介绍"></a> string 介绍</h1><p>标志库类型</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>string  字符</td><td>char*</td></tr><tr><td>vector   动态数组</td><td>静态数组[]</td></tr><tr><td>map   key/value</td><td>内部以树的形式存储 O(log2N) 哈希表 O(1)</td></tr></tbody></table><h2 id="string-介绍-2"><a class="markdownIt-Anchor" href="#string-介绍-2"></a> string 介绍</h2><ul><li>string 类型支持长度可变的字符串，C++ 标准库将负责管理与存储字符相关的内存，<a id="more"></a>以及提供各种有用的操作</li><li><code>typedef basic_string&lt;char&gt; string;</code>  模板类</li><li><code>typedef basic_string&lt;wchar_t wstring;</code> 模板类</li><li>要使用 string 类型对象，必须包含相关头文件 <code>#include&lt;string&gt; using std::string</code></li></ul><h2 id="string-对象的定义和初始化"><a class="markdownIt-Anchor" href="#string-对象的定义和初始化"></a> string 对象的定义和初始化</h2><ul><li><code>string s1;</code> // 默认构造函数，s1 为空串</li><li><code>steing s2(s1)</code> // 将 s2 初始化为 s1 的一个副本</li><li><code>string s3(&quot;value&quot;);</code> // 将 s3 初始化为一个字符串字面值副本</li><li><code>string s4(n,'c');</code> // 将 s4 初始化为字符串 ‘c’ 的 n 个副本</li><li>更多的见例子</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">string</span> s1;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;abcdefghijkl&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function">basic_string&lt;<span class="keyword">char</span>&gt; <span class="title">s3</span><span class="params">(<span class="string">&quot;xxx&quot;</span>)</span></span>; <span class="comment">//等价于 string s3(&quot;xxx&quot;)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s5</span><span class="params">(s2,<span class="number">3</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="number">4</span>, <span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::iterator first = s2.begin() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    string::iterator last = s2.end();</span></span><br><span class="line"><span class="built_in">string</span>::iterator last = s2.begin() + <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(first, last)</span></span>;  <span class="comment">//[first, lasr) 左闭右开</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s7 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abcdefghijkl</span></span><br><span class="line"><span class="comment">xxx</span></span><br><span class="line"><span class="comment">abcd</span></span><br><span class="line"><span class="comment">defghi</span></span><br><span class="line"><span class="comment">AAAA</span></span><br><span class="line"><span class="comment">bc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="常用的成员函数"><a class="markdownIt-Anchor" href="#常用的成员函数"></a> 常用的成员函数</h2><table><thead><tr><th>成员函数</th><th>功能描述</th></tr></thead><tbody><tr><td>size()</td><td>得到字符串大小</td></tr><tr><td>lentgh()</td><td>同上</td></tr><tr><td>empty()</td><td>判断是否为空</td></tr><tr><td>substr()</td><td>截取字符串</td></tr><tr><td>find()</td><td>在字符串中查找字符或者字符串</td></tr><tr><td>rfind()</td><td>反向查找</td></tr><tr><td>replace()</td><td>替代</td></tr><tr><td>compare()</td><td>比较字符串</td></tr><tr><td>insert()</td><td>插入字符</td></tr><tr><td>append()</td><td>追加字符串</td></tr><tr><td>swap()</td><td>交换字符串</td></tr><tr><td>重载运算符</td><td>[],+=,=,+,&gt;,&gt;=,&lt;,&lt;=,!=,==,&gt;&gt;,&lt;&lt;等</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;abcdefdg&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1.size() = &quot;</span> &lt;&lt; s1.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1.length() = &quot;</span> &lt;&lt; s1.length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.substr(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// s1 本身不发生变化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.substr(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 第2个参数默认是 nppos值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span>::size_type pos = s1.find(<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>); <span class="comment">// s1.rfind(&#x27;d&#x27;,2)</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pos = s1.rfind(<span class="string">&#x27;d&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">s1.size() = 8</span></span><br><span class="line"><span class="comment">s1.length() = 8</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">bc</span></span><br><span class="line"><span class="comment">bcdefdg</span></span><br><span class="line"><span class="comment">pos = 3</span></span><br><span class="line"><span class="comment">pos = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;abcdefghijkl&quot;</span>)</span></span>;</span><br><span class="line">   s1.replace(<span class="number">2</span>,<span class="number">2</span>,<span class="string">&quot;AAAAAA&quot;</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   s1 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">   s1.replace(s1.begin()+<span class="number">1</span>, s1.begin() + <span class="number">4</span>, <span class="string">&quot;BBBBB&quot;</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">string</span> s2 = <span class="string">&quot;xyzabc&quot;</span>;</span><br><span class="line">   s2.insert(<span class="number">2</span>,<span class="string">&quot;MMMM&quot;</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   s2.append(<span class="string">&quot;6666&quot;</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">string</span> s3 = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">   s2.swap(s3);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abAAAAAAefghijkl</span></span><br><span class="line"><span class="comment">aBBBBBefg</span></span><br><span class="line"><span class="comment">xyMMMMzabc</span></span><br><span class="line"><span class="comment">xyMMMMzabc6666</span></span><br><span class="line"><span class="comment">s2 = 111</span></span><br><span class="line"><span class="comment">s3 = xyMMMMzabc6666</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">string</span> s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">   s1[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//   const string s2 = &quot;xyz&quot;;</span></span><br><span class="line"><span class="comment">//   s2[1] = &#x27;Y&#x27;;   // error 非法的 不能给常量赋值 s2[1]返回的是 const char&amp;</span></span><br><span class="line"><span class="comment">//   string s3 = &quot;111&quot; + &quot;222&quot; + s1;  // error 前两个至少有一个是对象</span></span><br><span class="line">   <span class="built_in">string</span> s3 = <span class="string">&quot;111&quot;</span> + s1 + <span class="string">&quot;222&quot;</span> ;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//   fun(s3);  // 必须把 string 转换为 char*</span></span><br><span class="line"><span class="comment">//   s3.c_str();  //返回的是 const char*</span></span><br><span class="line"><span class="comment">//   fun(s3.c_str()); // error 不能将 const char* 转换为 char*</span></span><br><span class="line">   fun(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(s3.c_str()));</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">aBc</span></span><br><span class="line"><span class="comment">111aBc222</span></span><br><span class="line"><span class="comment">111aBc222</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>find_first_of 和 find_last_of</li><li>find_first_not_of 和 find_last_not_of</li><li>可以实现一个字符串去除左右空格</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> strinfo = <span class="string">&quot;//*---Hello World!......------&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> strset = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span>::size_type first = strinfo.find_first_of(strset);</span><br><span class="line">    <span class="keyword">if</span>(first == <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not find any characters&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span>::size_type last = strinfo.find_last_of(strset);</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not find any characters&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strinfo.substr(first, last - first + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LTrim</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span>; <span class="comment">// 去除左空格</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RTrim</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span>; <span class="comment">// 去除右空格</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Trim</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span>;  <span class="comment">// 去除左右空格</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringUtil::LTrim</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> drop = <span class="string">&quot; \t&quot;</span>;</span><br><span class="line">    <span class="comment">// 找到第一个不是空格的位置 find_first_not_of</span></span><br><span class="line">    s.erase(<span class="number">0</span>, s.find_first_not_of(drop)); <span class="comment">//去掉第一个不是空格位置之前的东西</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringUtil::RTrim</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> drop = <span class="string">&quot; \t&quot;</span>;</span><br><span class="line">    s.erase(s.find_last_not_of(drop) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringUtil::Trim</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LTrim(s);</span><br><span class="line">    RTrim(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去除左右空格</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot; abcd  &quot;</span>;</span><br><span class="line">    StringUtil::LTrim(s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    s = <span class="string">&quot; abcd  &quot;</span>;</span><br><span class="line">    StringUtil::RTrim(s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    s = <span class="string">&quot; abcd  &quot;</span>;</span><br><span class="line">    StringUtil::Trim(s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vector-介绍"><a class="markdownIt-Anchor" href="#vector-介绍"></a> vector 介绍</h1><h2 id="vector-介绍-2"><a class="markdownIt-Anchor" href="#vector-介绍-2"></a> vector 介绍</h2><ul><li>vector 是同一种类型的对象的集合</li><li>vector 的数据结构很像数据，能非常高效和方便地访问单个元素,空间是连续的，并且可以扩展</li><li>vector 是一个类模板 (class template)</li><li>要使用 vector 必须包含相关头文件 <code>#include &lt;vector&gt; using std::vector</code></li></ul><h2 id="vector-对象初始化"><a class="markdownIt-Anchor" href="#vector-对象初始化"></a> vector 对象初始化</h2><ul><li>vector 类定义了好几种构造函数<ul><li><code>vector&lt;T&gt; v1;</code> vector 保存类型为 T 的对象，默认构造函数 v1 为空</li><li><code>vector&lt;T&gt; v2(v1);</code> v2 是 v1 的一个副本</li><li><code>vector&lt;T&gt; v3(n,i)</code> v3 包含 n 个值为 i 的元素</li><li><code>vector&lt;T&gt; v4(n)</code> v4 含有值初始化的元素的 n 个副本</li></ul></li></ul><h2 id="vector-常用成员函数"><a class="markdownIt-Anchor" href="#vector-常用成员函数"></a> vector 常用成员函数</h2><table><thead><tr><th>成员函数</th><th>功能描述</th></tr></thead><tbody><tr><td>size()</td><td>返回元素的个数</td></tr><tr><td>clear()</td><td>清除所有元素</td></tr><tr><td>empty()</td><td>判断是否为空</td></tr><tr><td>push_back()</td><td>在末尾添加一个元素</td></tr><tr><td>erase()</td><td>删除某个元素</td></tr><tr><td>insert()</td><td>插入一个元素</td></tr><tr><td>[]</td><td>返回元素</td></tr><tr><td>=</td><td>复制副本</td></tr><tr><td>重载运算符</td><td>[],=,&gt;,&gt;=,&lt;,&lt;=,!=,==等</td></tr></tbody></table><ul><li>通过迭代器来遍历容器,迭代器可以将它看成是泛型程序指针</li><li>!= 具有更好的可移植性，基本所有容器都有 != ,但不一定重载了&lt; 号</li><li>it++ 如果后置的++运算符重载，会多了一次临时对象的创建</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ++it</span></span><br><span class="line"><span class="comment">//it++ 如果后置的++运算符重载，会多了一次临时对象的创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(INTVEC &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过迭代器来遍历容器,迭代器可以将它看成是泛型程序指针</span></span><br><span class="line">    INTVEC::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = v.begin(); it != v.end(); ++it) &#123; <span class="comment">// != 具有更好的可移植性，基本所有容器都有 != ,但不一定重载了&lt; 号</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; INTVEC;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void ShowVec(const INTVEC&amp; v)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    unsigned int i;</span></span><br><span class="line"><span class="comment">//    for (i = 0; i &lt; v.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(INTVEC &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过迭代器来遍历容器,迭代器可以将它看成是泛型程序指针</span></span><br><span class="line">    INTVEC::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = v.begin(); it != v.end(); ++it) &#123; <span class="comment">// != 具有更好的可移植性，基本所有容器都有 != ,但不一定重载了&lt; 号</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowVec_const</span><span class="params">(<span class="keyword">const</span> INTVEC &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 推荐带 const ，此时迭代器也要定义为 const_iterator</span></span><br><span class="line">    <span class="comment">// 通过迭代器来遍历容器,迭代器可以将它看成是泛型程序指针</span></span><br><span class="line">    INTVEC::const_iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = v.begin(); it != v.end(); ++it) &#123; <span class="comment">// != 具有更好的可移植性，基本所有容器都有 != ,但不一定重载了&lt; 号</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowVec1</span><span class="params">(INTVEC &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : v)   <span class="comment">// 新式的 for 循环写法</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    vector&lt;int&gt;  v;</span></span><br><span class="line">    INTVEC v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    v.push_back(<span class="number">6</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line">    v.push_back(<span class="number">7</span>);</span><br><span class="line">    ShowVec_const(v);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.back() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 并没有真正把最后一个弹出</span></span><br><span class="line">    ShowVec_const(v);</span><br><span class="line">    v.pop_back();</span><br><span class="line">    ShowVec_const(v);  <span class="comment">//此时弹出了3</span></span><br><span class="line"><span class="comment">//    v.erase(v.begin()+3); //删掉第4个元素</span></span><br><span class="line">    v.erase(v.begin(), v.begin()+<span class="number">2</span>); <span class="comment">//移除一个范围 左闭右开</span></span><br><span class="line">    ShowVec_const(v);</span><br><span class="line">    v.erase(remove(v.begin(),v.end(),<span class="number">5</span>),v.end()); <span class="comment">//移除所有的元素 5 &lt;algorithm&gt;中的算法</span></span><br><span class="line">    ShowVec_const(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 5 7 </span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 5 7 </span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 5 </span></span><br><span class="line"><span class="comment">3 4 5 6 5 </span></span><br><span class="line"><span class="comment">3 4 6 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>STL六大组件：容器、迭代器、算法、函数对象、适配器、内存分配器</p><h3 id="c-新标准中的-for-循环"><a class="markdownIt-Anchor" href="#c-新标准中的-for-循环"></a> c++ 新标准中的 for 循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration: expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>注意：这里expression表示的必须是一个序列，如用花括号括起来的初始值列表（{1,2,3,4}）、数组（[1,2,3,4]）或者vector或string等类型的对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;item : a)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : a)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h1 id="map-介绍"><a class="markdownIt-Anchor" href="#map-介绍"></a> map 介绍</h1><h2 id="map-介绍-2"><a class="markdownIt-Anchor" href="#map-介绍-2"></a> map 介绍</h2><p>标准库的 map 类型</p><ul><li>使用 map 需要包含 map 类所在的头文件 <code>#include &lt;map&gt;</code>，关联式容器，以 key-value 的形式存储</li><li>定义一个 map 对象 <code>map&lt;string, int&gt; mapTest; //string 作为索引，存储 int 对象</code></li></ul><h2 id="插入数据"><a class="markdownIt-Anchor" href="#插入数据"></a> 插入数据</h2><ul><li><code>mapTest[&quot;aaa&quot;] = 100;</code></li><li><code>mapTest.insert(map&lt;string,int&gt;::value_type(&quot;bbb&quot;,200));</code></li><li><code>mapTest.insert(pair&lt;string, int&gt;(&quot;ddd&quot;, 400));</code></li><li><code>mapTest.insert(make_pair&lt;string,int&gt;(&quot;ccc&quot;,300));</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 插入到 map 容器内部的元素默认是按照 key 从小到大来排序</span></span><br><span class="line">    <span class="comment">// key 类型一定要重载 &lt; 运算符</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapTest;</span><br><span class="line">    mapTest[<span class="string">&quot;aaa&quot;</span>] = <span class="number">100</span>; <span class="comment">// int&amp; operator[](const string&amp; index);</span></span><br><span class="line">    mapTest.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::value_type(<span class="string">&quot;bbb&quot;</span>, <span class="number">200</span>));</span><br><span class="line"><span class="comment">//    mapTest.insert(map&lt;string,int&gt;::value_type(&quot;bbb&quot;, 2000)); // 不允许插入</span></span><br><span class="line">    mapTest.insert(<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">&quot;ccc&quot;</span>, <span class="number">300</span>));</span><br><span class="line">    mapTest.insert(<span class="built_in">make_pair</span>(<span class="string">&quot;ddd&quot;</span>,<span class="number">400</span>));</span><br><span class="line">    mapTest[<span class="string">&quot;eee&quot;</span>] = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mapTest.begin(); it != mapTest.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找与修改"><a class="markdownIt-Anchor" href="#查找与修改"></a> 查找与修改</h2><ul><li><code>mapTest[&quot;aaa] = 100;</code></li><li>map&lt;string, int&gt;::iterator it = mapTest.find(“aaa”);</li><li>it-&gt;second = 666;</li></ul><h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2><ul><li><code>mapTest.erase(&quot;aaa&quot;);</code></li><li><code>mapTest.erase(it);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友元与运算符重载</title>
      <link href="posts/6ea8b1ca/"/>
      <url>posts/6ea8b1ca/</url>
      
        <content type="html"><![CDATA[<h1 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h1><h2 id="友元介绍"><a class="markdownIt-Anchor" href="#友元介绍"></a> 友元介绍</h2><ul><li>友元是一种允许非类成员函数访问类的非公有成员的一种机制</li><li>可以把一个函数指定为类的友元，也可以把整个类指定为另一个类的友元<ul><li>友元函数</li><li>友元类</li></ul></li></ul><h2 id="友元函数"><a class="markdownIt-Anchor" href="#友元函数"></a> 友元函数</h2><ul><li>友元函数在类的作用域外定义，但它需要在类体中进行说明；</li><li>为了与该类的成员函数加以区别，定义的方式是在类中用关键字 friend 说明该函数，格式如下： <code>friend 类型 友元函数名(参数表)</code>;</li><li>友元的作用在于提高程序的运行效率。</li><li>友元函数虽然不是类的成员函数，但是可以访问类的私有的，公有的，保护的成员对象。</li></ul><h2 id="友元函数注意事项"><a class="markdownIt-Anchor" href="#友元函数注意事项"></a> 友元函数注意事项</h2><ul><li>友元函数不是类的成员函数，在函数体中访问对象的成员，必须用对象名加运算符‘.'加对象成员名。但友元函数可以访问类中的所有成员（公有的，私有的，保护的），一般函数只能访问类中的公有成员。</li><li>友元函数不受类中的访问权限关键字限制，可以把它放在类的公有，私有，保护部分，结果一样；</li><li>某类的友元函数的作用域并非该类的作用域。如果该友元函数是另一类的成员函数，则其作用域为另一类的作用域，否则与一般函数相同。</li><li>友元函数破坏了面向对象程序设计类的封装性，所以友元函数如果不是必须使用，则尽量少用，或用其他手段保证封装性。</li></ul><h2 id="友元类"><a class="markdownIt-Anchor" href="#友元类"></a> 友元类</h2><ul><li>如果某类 B 的成员函数会频繁的存取另一个类 A 的数据成员，而 A 的数据成员的 Private/Protected 限制造成 B 存取的麻烦，B 只能通过 A 的 public 的成员函数进行间接存取。</li><li>把 B 做成 A 类的友元类，即 A 类向 B 类开发其 Private/Protected 内容，让 B 直接存取。</li><li>友元类：一个类可以作为另一类的友元</li><li>友元类的声明： <code>friend class 类名;</code></li></ul><h2 id="友元类注意事项"><a class="markdownIt-Anchor" href="#友元类注意事项"></a> 友元类注意事项</h2><ul><li>友元关系是单向的：A 是 B 的友元类（在 B 类中 friend class A)，并不代表 B 也是 A 的友元类；</li><li>友元关系不能被传递：A 是 B 的友元类，B 又是 C 的友元类，并不代表 A 是 C 的友元类；</li><li>友元关系不能被继承：A 是 B 的友元类，C 继承自 A，并不代表 C 是 B 的友元类。</li></ul><h1 id="运算符重载一"><a class="markdownIt-Anchor" href="#运算符重载一"></a> 运算符重载（一）</h1><h2 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h2><ul><li>运算符重载允许把标志运算符（如 + - * / &lt; &gt; 等）应用于自定义数据类型的对象</li><li>直观自然，可以提高程序的可读性</li><li>体现了 C++ 的可扩充性</li><li>运算符重载仅仅只是语法上的方便，它是另一种函数调用的方式</li><li>运算符重载，本质上是函数重载</li><li>不要滥用重载，因为它只是语法上的方便，所以只有在涉及的代码更容易写，尤其是更容易读时才有必要重载。</li></ul><h2 id="成员函数重载"><a class="markdownIt-Anchor" href="#成员函数重载"></a> 成员函数重载</h2><ul><li>成员函数原型的格式：<code>函数类型 operator 运算符（参数表）;</code></li><li>成员函数定义的格式：<code>类名::operator 运算发(参数表) &#123;函数体&#125;</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;other); <span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r = real_ + other.real_;</span><br><span class="line">    <span class="keyword">int</span> i = imag_ + other.imag_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Complex(r,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Complex c3 = c1 + c3; <span class="comment">// 等价于 Complex c3 = c1.operator+(c2) 或 Complex c3 = operator+(c1,c2);</span></span><br></pre></td></tr></table></figure><h2 id="非成员函数重载"><a class="markdownIt-Anchor" href="#非成员函数重载"></a> 非成员函数重载</h2><ul><li>友元函数原型的格式 <code>friend 函数类型 operator 运算符(参数表)；</code></li><li>友元函数定义的格式 <code>friend 函数类型 类名::operator 运算符（参数表）&#123;函数体;&#125;</code></li><li>成员函数调用的优先级大于非成员函数</li></ul><h2 id="运算符重载规则"><a class="markdownIt-Anchor" href="#运算符重载规则"></a> 运算符重载规则</h2><ul><li>运算符重载不允许发明新的运算符</li><li>不能改变运算符操作对象的个数</li><li>运算符被重载后，其优先级和结合性不会改变</li><li>不能重载的运算符：::、  ?:、   .、  .*、   sizeof</li><li>一般情况下，单目运算符最好重载为类的成员函数，双目运算符最后重载为类的友元函数</li><li>以下一些双目运算符不能重载为类的友元函数：= () [] -&gt;</li><li>类型转换运算符只能以成员函数方式重载</li><li>流运算符只能以友元的方式重载</li></ul><h1 id="运算符重载二"><a class="markdownIt-Anchor" href="#运算符重载二"></a> 运算符重载（二）</h1><h2 id="运算符重载-2"><a class="markdownIt-Anchor" href="#运算符重载-2"></a> ++ 运算符重载</h2><h3 id="前置-运算符重载"><a class="markdownIt-Anchor" href="#前置-运算符重载"></a> 前置 ++ 运算符重载</h3><ul><li>成员函数的方式重载，原型为：<code>函数类型 &amp; operator++()</code></li><li>友元函数的方式重载，原型为：<code>friend 函数类型 &amp; operator++(类类型 &amp;);</code></li></ul><h3 id="后置自增和后置自减的重载"><a class="markdownIt-Anchor" href="#后置自增和后置自减的重载"></a> 后置自增和后置自减的重载</h3><ul><li>成员函数的方式重载，原型为：<code>函数类型 &amp;operator++(int)</code></li><li>友元函数的方式重载，原型为：<code>friend 函数类型 &amp;operator++(类类型 &amp;，int)</code>;</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置 ++</span></span><br><span class="line">Integer&amp; <span class="keyword">operator</span> ++();</span><br><span class="line"></span><br><span class="line">Integer&amp; Integer::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;</span><br><span class="line">    ++n_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置 ++</span></span><br><span class="line">Integer <span class="keyword">operator</span> ++(<span class="keyword">int</span> i);</span><br><span class="line"></span><br><span class="line">Integer Integer::<span class="keyword">operator</span> ++(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用临时对象</span></span><br><span class="line">    <span class="function">Integer <span class="title">tmp</span><span class="params">(n_)</span></span>;</span><br><span class="line">    n_++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="运算符重载-3"><a class="markdownIt-Anchor" href="#运算符重载-3"></a> ！运算符重载</h2><p>当字符串非空的时候返回真，字符串空的时候返回假</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> !() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> String::<span class="keyword">operator</span> !() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(str_) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符重载"><a class="markdownIt-Anchor" href="#赋值运算符重载"></a> 赋值运算符重载</h2><p>当赋值操作时，默认是浅拷贝的，需要重载为深拷贝。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> String&amp; other);</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>= (<span class="keyword">const</span> String&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] str_;</span><br><span class="line">    str_ = AllocAndCopy(other.str_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符重载三"><a class="markdownIt-Anchor" href="#运算符重载三"></a> 运算符重载（三）</h1><h2 id="string类实现"><a class="markdownIt-Anchor" href="#string类实现"></a> String类实现</h2><h3 id="运算符重载-4"><a class="markdownIt-Anchor" href="#运算符重载-4"></a> [] 运算符重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>&amp; MyString::<span class="keyword">operator</span> [](<span class="keyword">unsigned</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回是引用，返回值可以作为左值</span></span><br><span class="line">    <span class="keyword">return</span> str_[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// non const 版本调用 const 版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> MyString&amp;&gt;(*<span class="keyword">this</span>)[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; MyString::<span class="keyword">operator</span> [](<span class="keyword">unsigned</span> index) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回是引用，返回值可以作为左值</span></span><br><span class="line">    <span class="keyword">return</span> str_[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>static_cast &lt; type-id &gt; ( expression )，该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。</li><li>dynamic_cast &lt; type-id &gt; ( expression )<br />说明：该运算符把expression转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用。</li><li>const_cast&lt;type_id&gt; (expression)<br />说明：该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。<br />常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</li></ul><h3 id="运算符重载-5"><a class="markdownIt-Anchor" href="#运算符重载-5"></a> + 运算符重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以友元的方式重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; s1, <span class="keyword">const</span> MyString&amp; s2);</span><br><span class="line"></span><br><span class="line">MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString&amp; s1, <span class="keyword">const</span> MyString&amp; s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s1.str_) + <span class="built_in">strlen</span>(s2.str_) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* newstr = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    <span class="built_in">memset</span>(newstr,<span class="number">0</span>,len);</span><br><span class="line">    <span class="built_in">strcpy</span>(newstr,s1.str_);</span><br><span class="line">    <span class="built_in">strcat</span>(newstr,s2.str_);</span><br><span class="line"></span><br><span class="line">    <span class="function">MyString <span class="title">tmp</span><span class="params">(newstr)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> newstr;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 借助 += 来实现</span></span><br><span class="line"><span class="comment">     MyString str = s1;</span></span><br><span class="line"><span class="comment">    str += s2;</span></span><br><span class="line"><span class="comment">    return srt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载-6"><a class="markdownIt-Anchor" href="#运算符重载-6"></a> += 运算符重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyString&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> MyString&amp; other);</span><br><span class="line"></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span> +=(<span class="keyword">const</span> MyString&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 借助 + 运算符来实现</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str_) + <span class="built_in">strlen</span>(other.str_) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* newstr = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    <span class="built_in">memset</span>(newstr,<span class="number">0</span>,len);</span><br><span class="line">    <span class="built_in">strcpy</span>(newstr,str_);</span><br><span class="line">    <span class="built_in">strcat</span>(newstr,other.str_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] str_;</span><br><span class="line">    str_ = newstr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流运算符c重载"><a class="markdownIt-Anchor" href="#流运算符c重载"></a> 流运算符c重载</h3><ul><li>C++ 的 I/O 流库的一个重要特性就是能够支持新的数据类型的输出和输入</li><li>用户可以通过对插入符（&lt;&lt;) 和提取符 (&gt;&gt;)进行重载来支持新的数据类型</li><li>流运算符的重载只能使用友元函数进行重载</li><li>为什么一定要用友元函数进行重载？第一个参数是流对象，不是自身，返回的是流对象的引用。</li><li><code>friend istream&amp; operator&gt;&gt;(istream&amp;, 类类型&amp;);</code></li><li><code>friend ostream&amp; operator&lt;&lt;(ostream&amp;, const 类类型&amp;);</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;&lt; 运算符重载</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> MyString&amp; str);</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> MyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; str.str_;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt; 运算符重载</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="运算符重载四"><a class="markdownIt-Anchor" href="#运算符重载四"></a> 运算符重载（四）</h1><h2 id="类型转换运算符"><a class="markdownIt-Anchor" href="#类型转换运算符"></a> 类型转换运算符</h2><ul><li>必须是成员函数，不能是友元函数</li><li>没有参数（操作数是什么）</li><li>不能指定返回类型（其实已经指定了）</li><li>函数原型 <code>operator 类型名（）；</code></li><li>可以将当前的类类型转换诶其他类型</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n_;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">n</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">n = <span class="number">200</span>; <span class="comment">// 会调用转换构造函数然后调用=运算符</span></span><br><span class="line">n.Display();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = add(n, <span class="number">100</span>); <span class="comment">// 参数传递会调用类型转换运算符的重载</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x = n;  <span class="comment">// 隐式转换</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(n); <span class="comment">// 显示转换</span></span><br></pre></td></tr></table></figure><h2 id="-指针运算符"><a class="markdownIt-Anchor" href="#-指针运算符"></a> -&gt; 指针运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="comment">// DB类相当于智能指针，包装了DBHelper</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DBHelper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;DBHelper...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBHelper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~DBHelper...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Open</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Open...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Close...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Query...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DB()</span><br><span class="line">    &#123;</span><br><span class="line">        db_ = <span class="keyword">new</span> DBHelper;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> db_;</span><br><span class="line">    &#125;</span><br><span class="line">    DBHelper* <span class="keyword">operator</span> -&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> db_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBHelper* db_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DB db;</span><br><span class="line">    db-&gt;Open();</span><br><span class="line">    db-&gt;Query();</span><br><span class="line">    db-&gt;Close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="operator-new-和-operator-delete"><a class="markdownIt-Anchor" href="#operator-new-和-operator-delete"></a> operator new 和 operator delete</h2><ul><li><code>void* operator new(size_t size)</code></li><li><code>void operator delete(void* p)</code></li><li><code>void operator delete(void* p, size_t size)</code></li><li><code>void* operator new(size_t size,const char* file, long line)</code></li><li><code>void operator delete(void* p, const char* file, long line)</code></li><li><code>void* operator new[](size_t size)</code></li><li><code>void operator delete[](void* p)</code></li><li><code>void operator delete[](void* p,size_t size)</code></li></ul><h3 id="new-三种用法"><a class="markdownIt-Anchor" href="#new-三种用法"></a> new 三种用法</h3><ul><li>new operator <code>Test* p1 = new Test(100); // new operator = operator new + 构造函数的调用</code></li><li>operator new 可以被重载</li><li>placement new 直接返回已经存在的地址</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// placement new</span></span><br><span class="line"><span class="keyword">char</span> chunk[<span class="number">10</span>]; <span class="comment">// 在已存在的内存空间上创建对象</span></span><br><span class="line">Test* p2 = <span class="keyword">new</span> (chunk) Test(<span class="number">200</span>); <span class="comment">// operator new(size_t, void *_Where)</span></span><br><span class="line"><span class="comment">// placement new 不分配内存</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> n) : n_(n)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test(int n) : n_(n)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;void* operator new(size_t size)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; void operator delete(void* p)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; void operator delete(void* p, size_t size)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载  placement new</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以有多个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">char</span>* file, <span class="keyword">long</span> line)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">char</span>* file, <span class="keyword">long</span> line)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global void* operator new(size_t size)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global void operator delete(void *p)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global void* operator new[](size_t size)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global void operator delete[](void *p)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test* p1 = <span class="keyword">new</span> Test(<span class="number">100</span>); <span class="comment">// new operator = operator new + 构造函数的调用</span></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">    <span class="keyword">delete</span> str;</span><br><span class="line">    <span class="keyword">char</span>* str1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] str1;</span><br><span class="line">    <span class="keyword">char</span> chunk[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// placement new</span></span><br><span class="line">    Test* p2 = <span class="keyword">new</span> (chunk) Test(<span class="number">200</span>);  <span class="comment">//operator new(size_t, void* _Where)</span></span><br><span class="line">                                       <span class="comment">// placement new 不分配内存 + 构造函数的调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p2-&gt;n_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    p2-&gt;~Test();       <span class="comment">// 显示调用析构函数</span></span><br><span class="line"><span class="comment">//    Test* p3 = (Test*)chunk;</span></span><br><span class="line">    Test* p3 = <span class="keyword">reinterpret_cast</span>&lt;Test*&gt;(chunk);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3-&gt;n_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> new new(__FILE__,__LINE__)</span></span><br><span class="line"><span class="comment">//    Test* p4 = new(__FILE__,__LINE__) Test(300); // 可以找出内存泄露的地方</span></span><br><span class="line">    Test* p4 = <span class="keyword">new</span> Test(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">delete</span> p4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void* operator new(size_t size)</span></span><br><span class="line"><span class="comment">Test(int n) : n_(n)</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment"> void operator delete(void* p)</span></span><br><span class="line"><span class="comment">global void* operator new(size_t size)</span></span><br><span class="line"><span class="comment">global void operator delete(void *p)</span></span><br><span class="line"><span class="comment">global void* operator new[](size_t size)</span></span><br><span class="line"><span class="comment">global void operator delete[](void *p)</span></span><br><span class="line"><span class="comment">Test(int n) : n_(n)</span></span><br><span class="line"><span class="comment">200</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">200</span></span><br><span class="line"><span class="comment">../25cpp/03.cpp:105</span></span><br><span class="line"><span class="comment">Test(int n) : n_(n)</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment"> void operator delete(void* p)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的使用</title>
      <link href="posts/9bbebf74/"/>
      <url>posts/9bbebf74/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的使用一"><a class="markdownIt-Anchor" href="#对象的使用一"></a> 对象的使用（一）</h1><h2 id="static-成员"><a class="markdownIt-Anchor" href="#static-成员"></a> static 成员</h2><ul><li>对于特定类型的全体对象而言，有时候可能需要访问一个全局的变量，比如说统计某种类型对象已创建的数量；</li><li>如果我们用全局变量会破坏数据的封装，一般的用户代码都可以修改这个全局变量，这时候我们可以用类的静态成员来解决这个问题；</li><li>非 static 数据成员存在于类类型的每个对象中，static 数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联。与所有的类对象是共享的</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CountedObject();</span><br><span class="line">    ~CountedObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count_;  <span class="comment">//静态成员的引用性声明，还需要有定义性的说明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CountedObject::count_ = <span class="number">100</span>;  <span class="comment">//  静态成员的定义性声明，不需要 static 关键字 ，初始化为 100,默认初始化为 0 </span></span><br><span class="line">   <span class="comment">// 在 .c 文件中</span></span><br></pre></td></tr></table></figure><p><strong>static 成员的优点</strong></p><ul><li>static 成员的名字是在类的作用域中，因此可以避免与其他类成员或全局对象名字冲突；</li><li>可以实施封装，static 成员可以是私有的，而全局对象不可以；如果 static 成员是私有的，意味着外部的代码不能访问该成员，需要提供公有的接口来访问。</li><li>阅读顺序可以看出 static 成员与某个类相关联，这种可见性可以清晰地反映程序员的意图。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CountedObject();</span><br><span class="line">    ~CountedObject();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetCount</span><span class="params">()</span></span>;  <span class="comment">//公有的接口访问私有的 count_ 成员</span></span><br><span class="line"><span class="keyword">private</span>:                    <span class="comment">// 私有的静态成员</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count_;  <span class="comment">//静态成员的引用性声明，还需要有定义性的说明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountedObject::GetCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>static 成员的定义<ul><li>static 成员需要在类定义体外进行初始化与定义</li></ul></li><li>特殊的整型 static const 成员<ul><li>整型 static const 成员可以在类定义体中初始化，</li><li>注意不能够多次初始化</li></ul></li></ul><h2 id="static-成员函数"><a class="markdownIt-Anchor" href="#static-成员函数"></a> static 成员函数</h2><ul><li>static 成员函数没有 this 指针</li><li>非静态成员函数可以访问静态成员</li><li>静态成员函数不可以访问非静态成员,静态成员函数不能调用非静态成员函数</li><li>静态成员函数不能访问非静态成员，因为静态成员函数没有 this 指针</li><li>访问静态成员函数可以 <code>Test::x_</code> 来访问，推荐这种方式，除此之外，还可以通过点的方式来访问<code>t.x_</code>,不推荐</li></ul><h2 id="类对象大小计算"><a class="markdownIt-Anchor" href="#类对象大小计算"></a> 类/对象大小计算</h2><ul><li>类大小计算遵循前面学过的结构体对齐原则</li><li>类的大小与数据成员有关，与成员函数无关</li><li>类的大小与静态数据成员无关</li><li>虚函数对类的大小的影响</li><li>虚继承对类的大小的影响</li></ul><h1 id="对象的使用二"><a class="markdownIt-Anchor" href="#对象的使用二"></a> 对象的使用（二）</h1><h2 id="static-成员函数的用法"><a class="markdownIt-Anchor" href="#static-成员函数的用法"></a> static 成员函数的用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year) : year_(year)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsLeapYear</span><span class="params">(<span class="keyword">int</span> year)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsLeapYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (year_ % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year_ % <span class="number">100</span> != <span class="number">0</span>) || (year_ % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> year_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 若不需要创建日期对象，仅仅是想判定日期是否是闰年，此时可以提供一个静态成员函数,静态函数类似 python 中的类函数</span></span><br><span class="line">    <span class="comment">// 不需要创建对象，就能够访问</span></span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2012</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.IsLeapYear() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Date::IsLeapYear(<span class="number">2010</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四种对象作用域与生存期"><a class="markdownIt-Anchor" href="#四种对象作用域与生存期"></a> 四种对象作用域与生存期</h2><ul><li>栈对象<ul><li>隐含调用构造函数（程序中没有显示调用）</li></ul></li><li>堆对象<ul><li>隐含调用构造函数（程序中没有显示调用）</li></ul></li><li>全局对象、静态全局对象<ul><li>全局对象的构造先于 main 函数</li><li>已初始化的全局变量或静态全局对象存储于 .data 段中</li><li>未初始化的全局变量或静态全局对象存储于 .bss 段中</li></ul></li><li>静态局部对象<ul><li>已初始化的静态局部变量存储于 .data 段中</li><li>未初始化的静态局部变量存储于 .bss 段中</li></ul></li><li>作用域与生存期不总是等同的</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test t;  <span class="comment">// 栈上创建对象，在生存期结束的时候能够自动释放</span></span><br><span class="line">Test *t3 = <span class="keyword">new</span> Test; <span class="comment">// 堆上创建的对象，要显示释放，即使跳出了作用域能需要显示释放 delete</span></span><br><span class="line"><span class="keyword">delete</span> t3;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> n) : n_(n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test...&quot;</span> &lt;&lt; n_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Test() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Test...&quot;</span> &lt;&lt; n_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;        <span class="comment">// 未初始化的全局变量，初始值为 0 ，n 存储于 .bss 段中（block started by symbol)</span></span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">101</span>; <span class="comment">// 已初始化的全局变量，初始值为 101，n2 存储于 .data 段中</span></span><br><span class="line"><span class="function">Test <span class="title">g</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 全局对象的构造先于 main 函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Test <span class="title">g2</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enetring main...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 栈上创建对象，在生存期结束的时候能够自动释放</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        Test *t3 = <span class="keyword">new</span> Test(<span class="number">30</span>); <span class="comment">// 堆上创建的对象，要显示释放，即使跳出了作用域能需要显示释放 delete</span></span><br><span class="line">        <span class="keyword">delete</span> t3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n3;          <span class="comment">//n3 存储于 .bss 段中  （编译期初始化）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n4 = <span class="number">102</span>;    <span class="comment">//n4 存储于 .data 段中 （编译期初始化）</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Test <span class="title">t4</span><span class="params">(<span class="number">333</span>)</span></span>;    <span class="comment">// t4 类对象运行期初始化  .data 段中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Exiting main...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">Test...100</span></span><br><span class="line"><span class="comment">Test...200</span></span><br><span class="line"><span class="comment">Enetring main...</span></span><br><span class="line"><span class="comment">Test...10</span></span><br><span class="line"><span class="comment">Test...20</span></span><br><span class="line"><span class="comment">~Test...20</span></span><br><span class="line"><span class="comment">Test...30</span></span><br><span class="line"><span class="comment">~Test...30</span></span><br><span class="line"><span class="comment">Test...333</span></span><br><span class="line"><span class="comment">Exiting main...</span></span><br><span class="line"><span class="comment">~Test...10</span></span><br><span class="line"><span class="comment">~Test...333</span></span><br><span class="line"><span class="comment">~Test...200</span></span><br><span class="line"><span class="comment">~Test...100</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><h2 id="static-用法总结"><a class="markdownIt-Anchor" href="#static-用法总结"></a> static 用法总结</h2><ol><li>用于函数内部修饰变量，即函数内的静态变量，这种变量的生存期长于该函数，使得函数具有一定的“状态”，使用静态变量的函数一般是不可以重入的，也不是线程安全的，比如 <code>strtok(3)</code></li><li>用在文件级别（函数体之外），修饰变量或函数，表示该变量或函数只在本文件可见，其他文件看不到也访问不到该变量或函数。专业的说法叫“具有 internal linkage” (简言之，不暴露给别的 translation unit)。C 语言的这两种用法很明确，一般也不容易混淆。由于 C++ 引入了类，在保持与 C 语言兼容的同时，static 关键字又有了两种新用法：</li><li>用于修饰类的数据成员，即所谓的“静态成员”。这种数据成员的生存期大于 class 的对象（实例/instance)。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份。</li><li>用于修饰 class 的成员函数，即所谓的“静态成员函数”。这种成员函数只能访问静态成员和其他静态成员函数，不能访问非静态成员和非静态成员函数（没有 this 指针）。</li></ol><h1 id="对象的使用三"><a class="markdownIt-Anchor" href="#对象的使用三"></a> 对象的使用（三）</h1><h2 id="static-与单例模式"><a class="markdownIt-Anchor" href="#static-与单例模式"></a> static 与单例模式</h2><p>单例模式：是一种设计模式，保证一个类只有一个实例，并提供一个全局访问点，禁止拷贝</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此种情况下，析构函数不会被调用，需要进一步改造</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            instance_ = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:                                            <span class="comment">//只需要把构造函数声明成私有的，单例模式</span></span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; other);              <span class="comment">// 拷贝构造函数声明为私有的，可以禁止拷贝</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Singleton&amp; other);  <span class="comment">// 赋值操作也声明私有的，禁止拷贝</span></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Singleton...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Singleton...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Singleton* instance_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Singleton s1;</span></span><br><span class="line"><span class="comment">//    Singleton s2;</span></span><br><span class="line">    Singleton* s1 = Singleton::GetInstance();</span><br><span class="line">    Singleton* s2 = Singleton::GetInstance();  <span class="comment">// 不管调用几次，返回的都是同一个对象，实例</span></span><br><span class="line">                                                <span class="comment">// 会发现没有调用析构函数，没有释放资源，会发生资源泄露的问题</span></span><br><span class="line"><span class="comment">//    Singleton s3(*s1);          // 调用拷贝函数，要禁止拷贝</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要定义嵌套类，仍然不是完美的解决方案</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            instance_ = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Singleton...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    static void Free()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        if (instance_ != NULL)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            delete instance_;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;  // 不能够自动释放</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Garbo</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~Garbo()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Singleton::instance_ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> instance_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:                                            <span class="comment">//只需要把构造函数声明成私有的，单例模式</span></span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; other);              <span class="comment">// 拷贝构造函数声明为私有的，可以禁止拷贝</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Singleton&amp; other);  <span class="comment">// 赋值操作也声明私有的，禁止拷贝</span></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Singleton...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance_;</span><br><span class="line">    <span class="keyword">static</span> Garbo garbo_;        <span class="comment">//当garbo_ 销毁时，会自动调用 Garbo 的析构函数，此时会释放掉 instance_</span></span><br><span class="line">                                <span class="comment">// 利用了对象的确定性析构</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton::Garbo Singleton::garbo_;</span><br><span class="line">Singleton* Singleton::instance_;</span><br><span class="line"><span class="comment">// 当程序结束的时候， garbo_ 的生存期结束，会调用该类的析构函数，析构函数里面会销毁 instance_,达到了销毁单例模式的对象目的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Singleton s1;</span></span><br><span class="line"><span class="comment">//    Singleton s2;</span></span><br><span class="line">    Singleton* s1 = Singleton::GetInstance();</span><br><span class="line">    Singleton* s2 = Singleton::GetInstance();  <span class="comment">// 不管调用几次，返回的都是同一个对象，实例</span></span><br><span class="line">                                                <span class="comment">// 会发现没有调用析构函数，没有释放资源，会发生资源泄露的问题</span></span><br><span class="line"><span class="comment">//    Singleton s3(*s1);          // 调用拷贝函数，要禁止拷贝</span></span><br><span class="line"><span class="comment">//    Singleton::Free();              // 对资源进行释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的实现单例模式，但是不是线程安全的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;      <span class="comment">// 局部静态对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Singleton...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:                                            <span class="comment">//只需要把构造函数声明成私有的，单例模式</span></span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; other);              <span class="comment">// 拷贝构造函数声明为私有的，可以禁止拷贝</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Singleton&amp; other);  <span class="comment">// 赋值操作也声明私有的，禁止拷贝</span></span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Singleton...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Singleton&amp; s1 = Singleton::GetInstance();</span><br><span class="line">    Singleton&amp; s2 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象的使用四"><a class="markdownIt-Anchor" href="#对象的使用四"></a> 对象的使用（四）</h1><h2 id="const-成员函数"><a class="markdownIt-Anchor" href="#const-成员函数"></a> const 成员函数</h2><ul><li>const 成员函数不会修改对象的状态</li><li>const 成员函数只能访问数据成员的值，而不能修改它</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> x) : x_(x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const GetX...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//        x_ = 100;           // 错误的</span></span><br><span class="line">        <span class="keyword">return</span> x_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span>      <span class="comment">// const 成员函数和非 const 成员函数可以构成重载</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;GetX...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> x_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    t.GetX();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="const-对象"><a class="markdownIt-Anchor" href="#const-对象"></a> const 对象</h2><ul><li>如果把一个对象指定为 const，就是告诉编译器不要修改它</li><li>const 对象的定义：<code>const 类名 对象名(参数表)</code></li><li>const 对象不能调用非 const 成员函数，只能够调用 const 成员函数</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//对象是常量，状态不能被更改</span></span><br><span class="line">t.GetX();   <span class="comment">//不能调用 Getx() 函数， const 对象不能调用非 const 成员函数，非 const 成员函数有修改对象的潜在风险，即使没有更改</span></span><br><span class="line">              <span class="comment">// 只能调用 const 成员函数</span></span><br></pre></td></tr></table></figure><h2 id="mutable"><a class="markdownIt-Anchor" href="#mutable"></a> mutable</h2><ul><li>用 mutable 修饰的数据成员即使在 const 对象或在 const 成员函数中都可以修改。</li><li><code>mutable int outputTimes_;</code></li></ul><h2 id="const-用法总结"><a class="markdownIt-Anchor" href="#const-用法总结"></a> const 用法总结</h2><ul><li><code>const int n= 100;</code> // 定义常量，必须初始化；</li><li><code>const Test t(10);</code> // 定义常量对象，必须初始化；</li><li><code>const int&amp; ref = n;</code> // const 引用可以引用 const 常量，普通引用不能引用 const 常量；<code>int&amp; ref = n; //error</code>；</li><li>const 与指针<ul><li><code>const int* p;</code> // const 出现在*左边，表示 <code>*p</code>是常量，const 修饰的是 p指针指向的对象（*p = 200; error)；</li><li><code>int* const p2;</code> // const 出现在*右边，表示 p2 是常量，(p2 = &amp;n; error)；</li><li><code>const int* const p3 = &amp;n3</code> // *p3是常量，p3也是常量；</li></ul></li><li>在类中，如果有 const 成员，const 成员的初始化只能在构造函数初始化列表中进行；</li><li>const 修饰成员函数，表示该成员函数不能修改对象状态，也就是它只能访问数据成员，但是不能修改数据成员。</li></ul><h1 id="一个实例看数据抽象与封装"><a class="markdownIt-Anchor" href="#一个实例看数据抽象与封装"></a> 一个实例看数据抽象与封装</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用 C++ 语言的方式实现栈操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> data_;</span><br><span class="line">        Link* next_;</span><br><span class="line">        Link(<span class="keyword">int</span> data, Link* next) : data_(data), next_(next) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack() : head_(<span class="number">0</span>), size_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ~Stack()</span><br><span class="line">    &#123;</span><br><span class="line">        Link* tmp;</span><br><span class="line">        <span class="keyword">while</span> (head_) &#123;</span><br><span class="line">           tmp = head_;</span><br><span class="line">           head_ = head_-&gt;next_;</span><br><span class="line">           <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       Link* node = <span class="keyword">new</span> Link(data, head_);</span><br><span class="line">       head_ = node;</span><br><span class="line">       ++size_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size_ == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span>&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Link* tmp = head_;</span><br><span class="line">        data = head_-&gt;data_;</span><br><span class="line">        head_ = head_-&gt;next_;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        --size_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Link* head_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 避免名称冲突</span></span><br><span class="line"><span class="comment">// 类型的扩充</span></span><br><span class="line"><span class="comment">// 数据封装，内部私有成员外部不能操作，能够保护内部的数据结构不遭受外界破坏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack <span class="built_in">stack</span>;  <span class="comment">// 抽象数据类型 类类型</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.Push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">stack</span>.Empty()) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.Pop(i);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数与析构函数</title>
      <link href="posts/70a8dfc8/"/>
      <url>posts/70a8dfc8/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数与析构函数一"><a class="markdownIt-Anchor" href="#构造函数与析构函数一"></a> 构造函数与析构函数（一）</h2><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><ul><li>构造函数是特殊的成员函数</li><li>创建类类型的新对象，系统自动会调用构造函数</li><li>构造函数是为了保证对象的每个数据成员都被正确初始化</li></ul><p>构造函数如何定义的？</p><ul><li>函数名和类名完全相同</li><li>不能定义构造函数的类型（返回类型），也不能使用 void</li><li>通常情况下构造函数应声明为公有函数，否则它不能像其他成员函数那样被显示调用</li><li>构造函数被声明为私有有特殊的用途</li><li>构造函数可以有任意类型和任意个数的参数，一个类可以有多个构造函数（重载）</li></ul><h3 id="默认构造函数"><a class="markdownIt-Anchor" href="#默认构造函数"></a> 默认构造函数</h3><ul><li>不带参数的构造参数称为默认构造函数</li><li>如果程序中未声明，则系统自动产生出一个默认构造函数</li><li>构造函数是可以被重载的</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//如果类不提供任何一个构造函数，系统将为我们提供一个不带参数的默认构造函数</span></span><br><span class="line">    Test();</span><br><span class="line">    Test(<span class="keyword">int</span> num);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test::Test()</span><br><span class="line">&#123;</span><br><span class="line">    num_ = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initiallizing Default&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    num_ = num;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initiallizing &quot;</span> &lt;&lt; num_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::Display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>全局对象的构造先于 main 函数。</strong></p><h3 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h3><ul><li>函数名和类名相似，前面多了一个字符 ~</li><li>没有返回类型，</li><li>没有参数，</li><li>析构函数不能被重载，</li><li>如果没有定义析构函数，编译器会自动生成一个默认析构函数，默认的析构函数是一个空函数，</li><li>先创建的对象，后被销毁 堆栈</li><li>析构函数可以显示调用，但一般很少用</li></ul><h3 id="析构函数与-delete"><a class="markdownIt-Anchor" href="#析构函数与-delete"></a> 析构函数与 delete</h3><ul><li>如果生成的数组，使用 delete 时必须配套使用 []</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test *t3 = <span class="keyword">new</span> Test[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">delete</span>[] t3; <span class="comment">//省略 [] 会发生运行时错误</span></span><br></pre></td></tr></table></figure><ul><li>当使用 delete 的时候，不只是释放了内存，还调用了对象的析构函数</li><li>析构函数可以显示调用</li><li>在栈区中创建的对象，在生存期结束的时候会自动调用析构函数</li><li>在堆上创建的对象，要有程序员显示的调用 delete 释放该对象，同时调用析构函数</li></ul><h2 id="构造函数与析构函数二"><a class="markdownIt-Anchor" href="#构造函数与析构函数二"></a> 构造函数与析构函数（二）</h2><h3 id="转换构造函数"><a class="markdownIt-Anchor" href="#转换构造函数"></a> 转换构造函数</h3><ul><li>单个参数的构造函数称为转换构造函数</li><li>可以将其他类型转换为类类型</li><li>类的构造函数只有一个参数是非常危险的，因为编译器可以使用这种构造函数把参数的类型隐式转换为类类型</li></ul><p>构造函数的作用：</p><ul><li>初始化类</li><li>类型转换（转换构造函数）</li></ul><p>带一个参数构造函数：</p><ul><li>普通的构造函数（初始化）</li><li>转换构造函数（初始化，类型转化）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Test t;</span></span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">//带一个参数的构造函数，充当的是普通构造函数的功能</span></span><br><span class="line"></span><br><span class="line">    t = <span class="number">20</span>; <span class="comment">// 将20这个整数赋值给 t 对象</span></span><br><span class="line">            <span class="comment">// 1. 调用转换构造函数将 20 这个整数转换成类类型（生成一个临时对象）</span></span><br><span class="line">            <span class="comment">// 2. 将临时对象赋值给 t 对象（调用的是 = 运算符）,赋值成功后会释放临时对象，会调用析构函数</span></span><br><span class="line">    Test t2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值与初始化区别"><a class="markdownIt-Anchor" href="#赋值与初始化区别"></a> 赋值与初始化区别</h3><ul><li>在初始化语句中的等号不是运算符。编译器对这种表示方法有特殊的解释，</li><li><code>Test t = 10; // 等价于Test t(10); 这里的 = 不是运算符，表示初始化，不是赋值操作</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test t = <span class="number">10</span>; <span class="comment">// 等价于Test t(10); 这里的 = 不是运算符，表示初始化，不是赋值操作</span></span><br><span class="line">t = <span class="number">20</span>;     <span class="comment">//赋值操作,需要转换构造函数生成临时对象，在赋值</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符重载"><a class="markdownIt-Anchor" href="#赋值运算符重载"></a> 赋值运算符重载</h3><p>当为一个类对象赋值（注意：可以用本类对象为其赋值，也可以用其它类型（如内置类型）的值为其赋值）时，会由该对象调用该类的赋值运算符重载函数。</p><p>当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动生成这样一个赋值运算符重载函数。</p><p>当用一个非类A的值（如上面的int型值）为类A的对象赋值时</p><ul><li>如果匹配的构造函数和赋值运算符重载函数同时存在，会调用赋值运算符重载函数。</li><li>如果只有匹配的构造函数存在，就会调用这个构造函数。</li></ul><p><code>t = t2; //赋值操作 等价于 t.operator=(t2) 返回的是 t 对象本身</code></p><h3 id="explicit"><a class="markdownIt-Anchor" href="#explicit"></a> explicit</h3><ul><li>explicit 是避免构造函数的参数自动转换为类对象的标识符</li><li>只提供给类的构造函数使用的关键字</li><li>编译器不会把声明为 explicit 的构造函数用于隐式转换，它只能在程序代码中显示创建对象</li><li>如果c++类的构造函数有一个参数，那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象-这是隐式的转换</li></ul><h2 id="构造函数与析构函数三"><a class="markdownIt-Anchor" href="#构造函数与析构函数三"></a> 构造函数与析构函数（三）</h2><h3 id="构造函数初始化列表"><a class="markdownIt-Anchor" href="#构造函数初始化列表"></a> 构造函数初始化列表</h3><ul><li>推荐在构造函数初始化列表中进行初始化</li><li>构造函数的执行分为两个阶段<ul><li>初始化阶段</li><li>普通计算阶段,函数体内部的属于普通计算阶段</li></ul></li><li>冒号后面是初始化列表</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Clock::Clock(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second) : hour_(hour), minute_(minute), second_(second)  <span class="comment">//采用初始化列表来初始化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    hour_ = hour;</span></span><br><span class="line"><span class="comment">//    minute_ = minute;</span></span><br><span class="line"><span class="comment">//    second_ = second;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Clock::CLock&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 属于普通计算阶段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象成员及其初始化"><a class="markdownIt-Anchor" href="#对象成员及其初始化"></a> 对象成员及其初始化</h3><ul><li>一个类可以包含普通的对象成员，也可以包含其他类类型的对象成员，子对象</li><li>构造次序与对象定义的顺序有关，与初始化列表无关</li><li>对数据成员的初始化推荐放在初始化列表中，包括普通的对象成员和对象数据成员</li><li>对象成员所对应的类没有默认的构造函数，初始化一定要放在初始化列表，如果有默认的构造函数，可以省略掉初始化列表</li></ul><h3 id="const-成员-引用成员初始化"><a class="markdownIt-Anchor" href="#const-成员-引用成员初始化"></a> const 成员、引用成员初始化</h3><ul><li>const 成员的初始化只能在构造函数的初始化列表中进行，在构造函数体内初始化本质是赋值，相当于对常量赋值，非法</li><li>引用成员的初始化也只能在构造函数初始化列表中进行</li><li>对象成员（对象所对应的类没有默认构造函数），对象成员的初始化也只能在构造函数初始化列表中进行</li></ul><h3 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h3><ul><li>枚举常量对所有对象都是常量，而 const 常量只是对当前对象是常量</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">E_TYPE</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        TYPE_A = <span class="number">100</span>,<span class="comment">// TYPE_A TYPE_B 对所有对象来说都是常量</span></span><br><span class="line">        TYPE_B = <span class="number">200</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="构造函数与析构函数四"><a class="markdownIt-Anchor" href="#构造函数与析构函数四"></a> 构造函数与析构函数（四）</h2><h3 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h3><ul><li>功能：使用一个已经存在的对象来初始化一个新的同一类型的对象，即由一个对象初始化另一个对象</li><li>声明：只有一个参数并且参数为该类对象的引用</li><li>如果类中没有说明拷贝构造函数，则系统自动生成一个缺省复制构造函数，作为该类的公有成员</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> Test(<span class="keyword">const</span> Test &amp;other); <span class="comment">// 拷贝构造函数 声明</span></span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">const</span> Test &amp;other) : num_(other.num_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    num_ = other.num_;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initializing with other &quot;</span> &lt;&lt; num_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(t)</span></span>; <span class="comment">//调用拷贝构造函数（如果没有写自己的拷贝构造函数，则系统默认提供的）</span></span><br><span class="line">Test t2 = t;  <span class="comment">//与 Test t2(t) 是等价的，相当于用 t 对象初始化 t2 对象</span></span><br></pre></td></tr></table></figure><p>拷贝构造函数的参数是对象的引用？本质是一个对象 t 初始化同一种对象 other，根据拷贝构造函数的定义，一个对象初始化同一种对象需要调用拷贝构造函数，如果不是引用，则实参到形参是值传递，other 会开辟新的内存，此时实参会初始化形参，此时又会调用拷贝构造函数，产生递归的调用。所以使用引用传递，不会产生新的内存，不会构造出一个新的对象。引用传递可以减少对象的复制，内存的拷贝，提高效率</p><h3 id="拷贝构造函数调用的几种情况"><a class="markdownIt-Anchor" href="#拷贝构造函数调用的几种情况"></a> 拷贝构造函数调用的几种情况</h3><ul><li>当函数的形参是类的对象，调用函数时，进行形参与实参结合使用，这时要在内存新建立一个局部对象，并把实参拷贝到新的对象中，理所当然也需要调用拷贝构造函数，当形参是类的引用时，不会调用拷贝构造函数，共享一块内存空间</li><li>当函数的返回值是类对象，函数执行完成返回调用者时使用。理由也是要建立一个临时对象中，在返回调用者。为什么不直接用要返回的局部对象呢？因为局部对象在离开建立它的函数时就消亡了，不可能在返回调用函数后继续生存。所以在处理这种情况时，编译系统会在调用函数的表达式中创建一个无名的临时对象，该临时对象的生命周期只在函数调用处的表达式中，所谓 return 对象，实际上是调用拷贝构造函数把该对象的值拷入临时对象，如果返回的是变量，处理过程类似，只是不调用构造函数。</li></ul><h2 id="构造函数与析构函数五"><a class="markdownIt-Anchor" href="#构造函数与析构函数五"></a> 构造函数与析构函数（五）</h2><h3 id="深拷贝与浅拷贝"><a class="markdownIt-Anchor" href="#深拷贝与浅拷贝"></a> 深拷贝与浅拷贝</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;AAA&quot;</span>)</span></span>;</span><br><span class="line">s1.Display();</span><br><span class="line">String s2 = s1;  <span class="comment">// 调用默认的拷贝构造函数</span></span><br><span class="line">                 <span class="comment">// 系统提供的默认拷贝构造函数实施的是浅拷贝 s2.str_ = s1.str_ </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>系统提供的默认拷贝构造函数实施的是浅拷贝 s2.str_ = s1.str_，仅仅将指针简单的指向 s2,没有重新分配内存。相当于两个对象指向同一个内存。当两个对象的生存周期结束是，都会调用各自的析构函数，会导致同一块内存被销毁 delete 两次，出现运行时错误。</li><li>解决方法是采用深拷贝，自己提供一个拷贝构造函数来实施深拷贝</li><li>如果涉及到动态内存分配，通常情况下实施的是深拷贝</li></ul><h3 id="赋值操作"><a class="markdownIt-Anchor" href="#赋值操作"></a> 赋值操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String s3;</span><br><span class="line">s3.Display();</span><br><span class="line">s3 = s2;       <span class="comment">// 会发生运行错误，本质是调用默认等号运算符</span></span><br><span class="line">               <span class="comment">// 系统提供的默认等号运算符实施的是浅拷贝，s3.str_ = s2.str_</span></span><br></pre></td></tr></table></figure><ul><li>系统提供的默认等号运算符实施的是浅拷贝,会导致同一块内存被销毁 delete 两次，出现运行时错误。</li><li>解决方法是自己提供一个等号运算符来实施深拷贝</li><li>采用自己的等号运算符相当于 s3.operator=(s2)</li></ul><h3 id="禁止拷贝"><a class="markdownIt-Anchor" href="#禁止拷贝"></a> 禁止拷贝</h3><ul><li>要让对象是五一无二的，我们要禁止拷贝</li><li>方法是将拷贝构造函数声明为私有，将等号运算符声明为私有，并且不提供实现</li></ul><h3 id="空类默认产生成员"><a class="markdownIt-Anchor" href="#空类默认产生成员"></a> 空类默认产生成员</h3><ul><li>class Empty{}</li><li>Empty(); // 默认构造函数</li><li>Empty(const Empty&amp;); // 默认拷贝构造函数</li><li>~Empty() // 默认析构函数</li><li>Empty&amp; operatpr=(const Empty&amp;); // 默认赋值运算符</li><li>Empty* operator&amp;(); // 默认取址运算符</li><li>const Empty* operator&amp;() const // 默认取址运算符 const</li></ul><p><code>Empty* p = &amp;e; // 等价于 e.operator&amp;();</code></p>]]></content>
      
      
      <categories>
          
          <category> C/C++学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象介绍</title>
      <link href="posts/e48c91fc/"/>
      <url>posts/e48c91fc/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象介绍"><a class="markdownIt-Anchor" href="#面向对象介绍"></a> 面向对象介绍</h2><h3 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3><h4 id="结构化程序设计"><a class="markdownIt-Anchor" href="#结构化程序设计"></a> 结构化程序设计</h4><ul><li>pascal之父 结构化程序设计先驱  迪杰斯特拉</li><li>程序 = 算法 + 数据结构</li><li>程序是完成一定功能的一系列有序指令的集合</li><li>这种设计方法是面向过程的，特点是数据与数据处理分离</li><li>结构化程序设计是自顶向下，将系统视为分层的子程序的集合，可以将程序分为功能不同的模块，使得整个程序更有条理性，但是很多数据仍然属于整个程序，因而结构化程序设计思想还是需要有很多的全局变量，在某个地方进行更改，所以会对整个程序产生难以预料的影响。</li><li>结构化程序设计的缺陷，其根源在于数据与数据处理的分离<ul><li>程序难以管理</li><li>数据修改存在问题</li><li>程序可重用性差</li><li>用户要求难以在系统分析阶段准确定义，致使系统在交付使用时产生许多问题</li><li>用系统开发每个阶段的成果来进行控制，不能适应事物变化的要求</li></ul></li></ul><h4 id="面向对象程序设计"><a class="markdownIt-Anchor" href="#面向对象程序设计"></a> 面向对象程序设计</h4><ul><li>面向将系统看成通过交互作用来完成特定功能的对象的集合，每个对象用自己的方法来管理数据也就是说只有对象内部的代码能够操作对象内部的数据</li><li>程序 = 对象 + 对象 + 对象 +  发生消息   对象 = 算法 + 数据</li><li>三个特性:<ul><li>封装</li><li>继承</li><li>多态</li></ul></li></ul><h3 id="面向对象程序设计-2"><a class="markdownIt-Anchor" href="#面向对象程序设计-2"></a> 面向对象程序设计</h3><ul><li>面向对象是认识事务的一种方法，是一种以对象为中心的思维方式<ul><li>对象 = 算法 + 数据结构</li><li>程序 = 对象 + 对象 + … + 对象</li></ul></li><li>面向对象将数据和对数据的操作放在一起，形成一个相对独立的整理-对象，同类对象还可抽象出共性，形成类（class）,一个类中的数据只能通过本类提供的方法进行处理，这些方法称为该类与外部的接口，对象之间通过消息（message）进行通讯。</li><li>对象之间只能通过函数调用也就是发送消息来实现相互通信</li></ul><h4 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h4><ul><li>封装是按照信息屏蔽的原则，把对象的属性和操作结合在一起，构成一个独立的对象</li><li>通过限制对属性和操作的访问权限，可以将属性隐藏在对象内部，对外提供一定接口，在对象之外只能通过接口对对象进行操作</li><li>封装性增加了对象的独立性，从而保证了数据的可靠性</li><li>外部对象不能直接操作对象的属性，只能使用对象提供的服务</li></ul><h4 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h4><ul><li>继承表达了对象的一般与特殊的关系，特殊类的对象具有一般类的全部属性和服务</li><li>继续性大大简化了对问题的描述，大大提高了程序的可重用性</li></ul><h4 id="多态性"><a class="markdownIt-Anchor" href="#多态性"></a> 多态性</h4><ul><li>多态性：同一个消息被不同对象接收时，产生不同的结果，即实现同一接口，不同方法</li><li>一般类中定义的属性和服务，在特殊类中不改变其名字，但通过各自不同的实现后，可以具有不同的数据类型或不同的行为</li><li>多态使我们能够以一致的观点来看待不同（但又大相径庭的）对象，同一个消息发送到不同的对象，就会呈现出不同的行为</li></ul><h4 id="继承与多态"><a class="markdownIt-Anchor" href="#继承与多态"></a> 继承与多态</h4><p>继承和多态的组合，可以生成很多相似但又独一无二的对象。</p><h4 id="面向对象编程方法的特性"><a class="markdownIt-Anchor" href="#面向对象编程方法的特性"></a> 面向对象编程方法的特性</h4><ul><li>程序设计的重点在数据而不是函数</li><li>程序由对象组成，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为</li><li>对象之间通过相互协作来完成功能</li><li>函数与相关的数据紧密结合</li><li>数据可以被隐藏</li><li>很容易扩充新的数据和函数</li></ul><h2 id="类与对象一"><a class="markdownIt-Anchor" href="#类与对象一"></a> 类与对象（一）</h2><h3 id="类声明"><a class="markdownIt-Anchor" href="#类声明"></a> 类声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类是一种用户自定义的类型,声明形式:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    公有成员(外部接口)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    私有成员</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    保护成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="公有-私有-保护成员"><a class="markdownIt-Anchor" href="#公有-私有-保护成员"></a> 公有、私有、保护成员</h3><ul><li>在关键字 public 后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数</li><li>在关键字 private 后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问</li><li>在关键字 protected 后面声明，与 private 类似，其差别表现在继承与派生时对派生类的影响不同, protected 在派生类是可以访问的。</li></ul><h3 id="数据抽象和封装"><a class="markdownIt-Anchor" href="#数据抽象和封装"></a> 数据抽象和封装</h3><ul><li>数据抽象是一种依赖于接口和实现分离的编程（和设计）技术，类设计者必须关系类是如何实现的，但使用该类的程序员不必了解这些细节，使用者只要抽象的考虑该类型做什么，而不必具体的考虑该类如何工作。</li></ul><h2 id="类与对象二"><a class="markdownIt-Anchor" href="#类与对象二"></a> 类与对象（二）</h2><ul><li>内联函数可以提高效率，编译的时候将代码直接嵌入到调用的地方，从而减少函数调用的开销，但是体积增大，是以空间换时间</li><li>内联函数仅仅是给编译器一个提示，如果函数中有 switch for 则不会展开.</li></ul><h3 id="内联成员函数"><a class="markdownIt-Anchor" href="#内联成员函数"></a> 内联成员函数</h3><p>两种实现方式</p><ul><li>在类外部添加 inline 关键字实现</li><li>在类内直接实现函数，不需要加关键字</li></ul><h3 id="成员函数的重载及其缺省参数"><a class="markdownIt-Anchor" href="#成员函数的重载及其缺省参数"></a> 成员函数的重载及其缺省参数</h3><p>函数的重载要具有相同的作用域</p><p>声明函数的可以设置缺省参数，注意二义性</p><h3 id="类与结构体"><a class="markdownIt-Anchor" href="#类与结构体"></a> 类与结构体</h3><p>class 和 struct 的区别：在未指定访问权限时，class 默认是私有的， struct 默认是公有的</p><h3 id="隐含的-this-指针"><a class="markdownIt-Anchor" href="#隐含的-this-指针"></a> 隐含的 this 指针</h3><ul><li>成员函数有一个隐含的附加形参，即指向该对象的指针，这个隐含的形参叫做 this 指针</li><li>使用 this 指针保证了每个对象可以拥有不用的数据成员，但处理这些成员的代码可以被所有对象共享</li><li>t1.Init(&amp;t1, 10, 20, 30) &amp;t1 就是 this 指针</li><li>t2.Init(&amp;t2, 1, 2, 3)</li></ul><h2 id="类与对象三"><a class="markdownIt-Anchor" href="#类与对象三"></a> 类与对象（三）</h2><h3 id="类作用域"><a class="markdownIt-Anchor" href="#类作用域"></a> 类作用域</h3><ul><li>每个类都定义了自己的作用域称为类作用域</li><li>类作用域中说明的标识符只要类中可见</li></ul><ol><li>块作用域</li><li>文件作用域</li><li>函数原型作用域</li><li>函数作用域</li><li>类作用域</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//num_ = 20; Error num_的作用域在类内部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_ = <span class="number">20</span>; <span class="comment">// num_的作用域是文件作用域,与类中的num_是不同的作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; <span class="comment">// a, b 两个标识符的作用域为函数原型作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_ = <span class="number">10</span>; <span class="comment">//num_ 为块作用域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num_ = <span class="number">100</span>; <span class="comment">//num_ 为块作用域</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ::num_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>   <span class="comment">// 形参 a b 也算是块作用域</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LABEL1:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;label1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL3;</span><br><span class="line">    LABEL2:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;label2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL1;</span><br><span class="line">    LABEL3:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;label3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前向声明"><a class="markdownIt-Anchor" href="#前向声明"></a> 前向声明</h3><ul><li>C++ 中类必须先定义，才能够实例化</li><li>两个类需要相互引用形成一个“环形”引用时，无法先定义使用，这时候需要用到前向声明</li><li>前向声明的类不能实例化，只能用指针或引用 A* a_;</li></ul><h3 id="嵌套类"><a class="markdownIt-Anchor" href="#嵌套类"></a> 嵌套类</h3><ul><li>外围类需要使用嵌套类对象作为底层实现，并且该嵌套类只能用于外围类的实现，且同时可以对用户隐藏该底层实现。</li><li>从作用域的角度看，嵌套类被隐藏在外围类之中，该类名只能在外围类中使用，如果在外围类的作用域使用该类名时，需要加名字限定</li><li>嵌套类中的成员函数可以在它的类体外定义</li><li>嵌套类的成员函数对外围类的成员没有访问权，反之亦然</li><li>嵌套类仅仅只是语法上的嵌入</li></ul><h3 id="局部类"><a class="markdownIt-Anchor" href="#局部类"></a> 局部类</h3><ul><li>类也可以定义在函数体内，这样的类被称为局部类（local class),局部类只有在定义它的局部域内可见</li><li>局部类的成员函数必须被定义在类体中</li><li>局部类中不能有静态成员</li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 C 到 C++</title>
      <link href="posts/dcd6586c/"/>
      <url>posts/dcd6586c/</url>
      
        <content type="html"><![CDATA[<h1 id="const-限定符"><a class="markdownIt-Anchor" href="#const-限定符"></a> const 限定符</h1><h2 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h2><ul><li>用 const 给字面常量起个名字，这个标识符就称为标识符常量，也成为常变量</li><li>定义的一般形式：<ul><li>const 数据类型 常量名 = 常量值</li><li>数据类型 const 常量名 = 常量值</li></ul></li><li>注意事项：<ul><li>常变量在定义时必须初始化</li><li>常变量在初始化之后，不允许再被赋值</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    const int a; // Error, 常量必须初始化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//    a = 200;    // Error 常量不能重新被赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p; <span class="comment">// const 在 * 左边,表示 *p 是一个常量,经由 *p 不能更改指针所指向的内容</span></span><br><span class="line">    p = &amp;b;</span><br><span class="line"><span class="comment">//    *p = 200;       // Error, 常量不能被重新赋值</span></span><br><span class="line"><span class="comment">//    int * const p2; // Error, p2 为常量 常量必须初始化</span></span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;b; <span class="comment">//const 在 * 右边,表示 p2 为常量</span></span><br><span class="line"><span class="comment">//    int c = 100;</span></span><br><span class="line"><span class="comment">//    p2 = &amp;c; // Error 常量不能重新被赋值</span></span><br><span class="line"></span><br><span class="line">    *p2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const-与-define"><a class="markdownIt-Anchor" href="#const-与-define"></a> const 与 #define</h2><p>const 定义的常量与 #define 定义的符号常量的区别</p><ul><li>const 定义的常量有类型，而 #define 定义的没有类型，编译可以对前者进行类型安全检查，而后者仅仅只是做简单替换</li><li>const 定义的常量在编译时分配内存，而 #define 定义的常量在预编译时进行替换，不分配内存</li><li>作用域不同，const 定义的常变量的作用域为该变量的作用域范围，而 #define 定义的常量作用域为它的定义点到程序结束，可以在某个地方用 #undef 取消</li><li>定义常量还可以用 enum, 尽量用const enum 替换 #define 定义常量，inline 可以替换宏定义</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(a) #a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT(a, b) a##b</span></span><br><span class="line"><span class="keyword">int</span> xy = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; STR(ABCD) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//#ABCD &lt;=&gt; &quot;ABCD&quot;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; CAT(x, y) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//x##y &lt;=&gt; xy</span></span><br></pre></td></tr></table></figure><h1 id="结构体-域位运算-重载"><a class="markdownIt-Anchor" href="#结构体-域位运算-重载"></a> 结构体、域位运算、重载</h1><h2 id="结构体内存对齐"><a class="markdownIt-Anchor" href="#结构体内存对齐"></a> 结构体内存对齐</h2><ul><li>什么是内存对齐<ul><li>编译器为每个数据单元安排在某个合适的位置上</li><li>c 、c++ 语言非常灵活，它允许干涉“内存对齐”</li></ul></li><li>为什么要对齐<ul><li>性能原因：在对齐的地址上访问数据块</li></ul></li><li>如何对齐<ul><li>第一个数据成员放在 offset 为 0 的位置</li><li>其他成员对齐至 <code>min(sizeof(member), #pragma pack 所指定的值）</code>的整数倍</li><li>整个结构体也要对齐，结构体总大小对齐至各个成员中最大对齐数的整数倍</li></ul></li></ul><h2 id="域运算符"><a class="markdownIt-Anchor" href="#域运算符"></a> 域运算符</h2><p>C++ 中增加的作用域标识符 ::</p><ul><li>用于对与局部变量同名的全局变量进行访问</li><li>用于表示类的成员，将在类的一节中详细说明</li></ul><h2 id="new-delete-运算符"><a class="markdownIt-Anchor" href="#new-delete-运算符"></a> new delete 运算符</h2><ul><li>new 运算符可以用于创建堆空间</li><li>成功返回首地址</li><li>语法：<ul><li>指针变量 = new 数据类型</li><li>指针变量 = new 数据类型[长度n]</li></ul></li><li>例如<br /><code>int *p; p = new int;</code><br /><code>char *pStr = new char[50];</code></li><li>new 一个新对象<ul><li>内存分配</li><li>调用构造函数</li></ul></li><li>new operator   内存分配 + 调用构造函数</li><li>operator new   只分配内存</li><li>placement new  不分配内存，调用拷贝构造函数</li><li>delete运算符 用于释放堆空间</li><li>语法：<ul><li>delete 指针变量；</li><li>delete[] 指针变量；</li><li>delete p;</li><li>delete[] pStr;</li></ul></li><li>delete 释放一个对象<ul><li>调用析构函数</li><li>释放内存（operator delete)</li></ul></li></ul><h2 id="重载"><a class="markdownIt-Anchor" href="#重载"></a> 重载</h2><ul><li>相同的作用域，如果两个函数名称相同，而参数不同，称为重载 overload</li><li>函数重载又称为函数的多态性 （静态的多态）</li><li>函数重载不同形式：<ul><li>形参数量不同</li><li>形参类型不同</li><li>形参的顺序不同</li><li>形参数量和类型都不同</li></ul></li><li>调用重载函数时，编译器通过检查实际参数的个数、类型和顺序来确定相应的被调用函数。</li><li>如果返回类型不同而函数名相同、形参也相同，则是非法的，会报错</li><li>c++ 为了支持重载，需要进行 name managling 名字改编</li><li>extern “C” 实现 C 与 C++ 的混合编程</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus             <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*…*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extern &quot;C&quot;的主要作用就是为了能够正确实现C<ins>代码调用其他C语言代码。加上extern &quot;C&quot;后，会指示编译器这部分代码按C语言的进行编译，而不是C</ins>的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。</p><h3 id="带默认形参值的函数"><a class="markdownIt-Anchor" href="#带默认形参值的函数"></a> 带默认形参值的函数</h3><ul><li><p>函数在声明或定义时，可以给形参赋一些默认值</p></li><li><p>调用函数时，若没有给出实参，则按指定的默认值进行工作</p></li><li><p>函数没有声明时，在函数定义中指定形参的默认值</p></li><li><p>函数既有定义又有声明时，声明时制定后，定义后不能再指定默认值</p></li><li><p>默认值的定义必须遵守从右到左的顺序，如果某个形参没有默认值，则它左边的参数就不能有默认值</p><ul><li><code>void func1(int a, double b = 4.5, int c = 3); //合法</code></li><li><code>void func1(int a = 1, double b, int c = 3); //不合法</code></li></ul></li><li><p>函数调用时，实参与形参按从左到右的顺序进行匹配</p></li></ul><h3 id="带默认形参值的函数的二义性"><a class="markdownIt-Anchor" href="#带默认形参值的函数的二义性"></a> 带默认形参值的函数的二义性</h3><ul><li>重载的函数中如果形参中带有默认值，可能产生二义性</li><li>sum = add(10,20)语句产生二义性，可以认为该语句是调用第一个函数，也可以是第二个，因此编译器不能确定是哪一个函数。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">5</span>, <span class="keyword">int</span> y = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">5</span>, <span class="keyword">int</span> y = <span class="number">6</span>, <span class="keyword">int</span> z = <span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum = add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// sum = add(10,20)语句产生二义性，可以认为该语句是调用第一个函数，也可以是第二个，因此编译器不能确定是哪一个函数。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><h2 id="引用-2"><a class="markdownIt-Anchor" href="#引用-2"></a> 引用</h2><p>引用不是变量，仅仅是变量的别名，引用没有自己独立的空间，要与它所引用的变量共享空间，对引用所做的改变其实是对它所引用的变量的改变。</p><ul><li>引用是给一个变量起别名</li><li>定义引用的一般格式：<ul><li>类型 &amp;引用名 = 变量名；</li><li>int a = 1; int &amp;b = a; // b 是 a 的别名，因此 a 和 b 是同一个单元</li></ul></li><li>定义引用时一定要初始化，指明该引用变量是谁的别名</li><li>在实际应用中，引用一般用作参数传递与返回值</li><li>引用一经初始化，不能重新指向其他变量</li></ul><h2 id="const-引用"><a class="markdownIt-Anchor" href="#const-引用"></a> const 引用</h2><p>const 引用是指向 const 对象的引用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; refVal = ival; <span class="comment">//OK, 引用和常量都是 const</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref2 = ival; <span class="comment">//Error, 非 const 引用引用一个 const 对象</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; refVal = val;</span><br><span class="line"><span class="comment">//    int&amp; ref2 = val; // Error, nonconst reference to const object</span></span><br><span class="line"><span class="comment">//    refVal = 200;     // Error, refVal 是一个常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref3 = val2; <span class="comment">// const reference to nonconst object</span></span><br><span class="line">    <span class="keyword">double</span> val3 = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref4 = val3;  <span class="comment">// int temp = val3;</span></span><br><span class="line">                            <span class="comment">// const int&amp; ref4 = tmp;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ref4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    int&amp; ref5 = val3;  //Error</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按引用传递"><a class="markdownIt-Anchor" href="#按引用传递"></a> 按引用传递</h2><p>参数传递：值传递和指针传递</p><ul><li>值传递  形参不能更改实参</li><li>指针传递形参可以改变实参</li></ul><p>按引用传递</p><ul><li>引用传递方式是在函数定义时在形参前面加上引用符号<code>&amp;</code>,<code>swap(int &amp;a, int &amp;b)</code></li><li>按值传递方式容易理解，但形参值的改变不能对实参产生影响</li><li>地址传递方式通过形参的改变使相应的实参改变，但程序容易引起错误且难以阅读</li><li>引用作为参数对形参的任何操作都能改变相应的实参的数据，又使函数调用显得方便、自然。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    swap(a,b); <span class="comment">// 在函数调用时, 引用被初始化 x = a, y = b;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用作为返回值"><a class="markdownIt-Anchor" href="#引用作为返回值"></a> 引用作为返回值</h2><ul><li>引用的另一个作用是用于返回引用的函数</li><li>函数返回引用的一个主要目的是可以将函数放在赋值运算符的左边</li><li>注意：不能返回对局部变量的引用</li><li>返回引用：当函数返回引用类型的时候，没有复制返回值，而是返回对象的引用（即对象本身）。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 引用作为函数返回值</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">index</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i];      <span class="comment">//  返回第 i 个元素的引用,引用在函数返回的时候初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    index(<span class="number">3</span>) = <span class="number">100</span>;   <span class="comment">// 引用作为函数返回值,使得函数可以放在赋值运算符左边</span></span><br><span class="line">                      <span class="comment">// 函数返回引用,引用在函数返回的时候初始化</span></span><br><span class="line">                      <span class="comment">// index(3)是一个引用, 在函数返回的时候被初始化为 a[3]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能返回对局部变量的引用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 引用作为函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span>&amp; n2 = add(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// n2 是引用,没有自己独立的空间</span></span><br><span class="line">                         <span class="comment">// n2 的值依赖于它所引用的变量</span></span><br><span class="line">                         <span class="comment">// 如果 n2 所引用的变量的生命期结束了,也就是 n2</span></span><br><span class="line">                         <span class="comment">// 是一个无效的引用, n2 的值是不确定的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;n2 = &quot; &lt;&lt; n2 &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n2 = &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用与指针区别"><a class="markdownIt-Anchor" href="#引用与指针区别"></a> 引用与指针区别</h2><ul><li>引用访问一个变量是直接访问，而指针是间接访问</li><li>引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间</li><li>引用一经初始化不能再引用其他变量，而指针可以</li><li>尽可能使用引用， 不得已时使用指针</li></ul><p>参数传递：</p><ul><li>值传递  实参要初始化形参参数要分配空间，将实参内容拷贝到形参</li><li>引用传递 实参初始化时不分配空间</li><li>指针传递 本质值传递，如果我们要修改指针的地址，单纯使用指针传递也是不行的。</li></ul><h1 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h1><h2 id="内联函数-2"><a class="markdownIt-Anchor" href="#内联函数-2"></a> 内联函数</h2><ul><li>当程序执行函数调用时，系统要建立栈空间，保护现场，传递参数以及控制程序执行的转移等等，这些工作需要系统时间和空间的开销。有些情况下，函数本身功能简单，代码很短，但使用频率很高，程序频繁调用该函数所花时间却很多，从而降低程序执行效率</li><li>为了提高效率，一个解决办法就是不使用函数，直接将函数的代码嵌入到程序中，但也有缺点：一个相同的代码重复书写，而是程序的可读性没有使用函数好</li><li>为了协调效率和可读性之间的矛盾，C++ 提供了另一种方法，即定义内联函数，方法是定义函数时用修饰词 <code>inline</code>，内联函数在编译的时候是展开的，不涉及函数调用</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a: b;</span><br><span class="line">&#125;</span><br><span class="line">#define MAX(a, b) (a) &gt; (b) ? (a) : (b)</span><br></pre></td></tr></table></figure><h2 id="内联函数与带参数宏区别"><a class="markdownIt-Anchor" href="#内联函数与带参数宏区别"></a> 内联函数与带参数宏区别</h2><ul><li>内联函数调用时，要求实参和形参的类型一致，另外内联函数会先对实参表达式进行求值，然后传递给形参；而宏调用时只是用实参简单的替换形参</li><li>内联函数是在编译的时候、在调用的地方将代码展开的，而宏是在预处理时进行替换的</li><li>在 C++ 中建议采用 <code>inline</code> 函数来替换带参数的宏</li><li>在 C++ 高层次编程 推荐用 <code>const</code> <code>enum</code> <code>inline</code> 替换宏，在低层次编程中，宏很灵活</li></ul><h1 id="新的类型转换运算符"><a class="markdownIt-Anchor" href="#新的类型转换运算符"></a> 新的类型转换运算符</h1><ul><li>旧式转型：<ul><li>（T)expr</li><li>T(expr)</li></ul></li><li>新式转换<ul><li><code>const_cast&lt;T&gt;(expr)</code></li><li><code>static_cast&lt;T&gt;(expr)</code></li><li><code>reinterpret_cast&lt;T&gt;(expr)</code></li><li><code>dynamic_cast&lt;T&gt;(expr)</code> 执行”安全向下“转型操作，也就是说支持运行时识别指针或所指向的对象，这是唯一一个无法用旧式语来进行的转型操作</li></ul></li></ul><h2 id="const_cast"><a class="markdownIt-Anchor" href="#const_cast"></a> const_cast</h2><ul><li>用来移除对象的常量性（cast away the constness)</li><li>const_cast 一般用于指针或引用，不能用于对象</li><li>使用 const_cast 去除 const 限定的目的不是为了修改它的内容</li><li>使用 const_cast 去除 const 限定，通常是为了函数能够接受这个实际参数</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fun = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//    int n = const_cast&lt;int&gt;(val);  error</span></span><br><span class="line">    <span class="keyword">int</span> n = val;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    int* p = &amp;val; error, 无法从 const int* 转换为 int*</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;val);</span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> val2 = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//    int&amp; refval2 = val2;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; refval2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(val2);</span><br><span class="line">    refval2 = <span class="number">300</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    fun(val2);      // error</span></span><br><span class="line">    fun(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(val2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static_cast"><a class="markdownIt-Anchor" href="#static_cast"></a> static_cast</h2><ul><li>编译器隐式执行的任何类型转换都可以由 <code>static_cast</code> 来完成，隐式转换是编译器自动执行的</li><li>当一个较大的算术类型赋值给较小的类型时，可以用 static_cast 进行强制转换</li><li>可以将 <code>void*</code> 指针转为某一类型指针</li><li>可以将基类指针转为派生类指针</li><li>无法将 const 转为为 nonconst，只能使用 const_cast</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;n;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p);</span><br></pre></td></tr></table></figure><h2 id="reinterpret_cast"><a class="markdownIt-Anchor" href="#reinterpret_cast"></a> reinterpret_cast</h2><ul><li>reinterpret_cast 通常为操作数的位模式提供较底层的重新解释，也就是说将数据以二进制存在形式的重新解释</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;This is a example&quot;</span>;</span><br><span class="line">i = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(p);</span><br><span class="line"><span class="comment">//此时结果,i与p的值完全相同的</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);</span><br><span class="line"><span class="comment">//程序员需要记得pc所指向的真是对象是 int 型,并非字符串</span></span><br><span class="line"><span class="comment">//如果将pc当作字符串指针进行操作,可能会造成运行时错误</span></span><br><span class="line"><span class="comment">//如 int len = strlen(pc);</span></span><br></pre></td></tr></table></figure><h2 id="转型规则"><a class="markdownIt-Anchor" href="#转型规则"></a> 转型规则</h2><ul><li>尽量避免使用强制类型转换</li><li>若无法避免，尽量使用新式的类型转换</li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
